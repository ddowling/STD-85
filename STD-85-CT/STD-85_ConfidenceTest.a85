;********************************************************************
;********************************************************************
;******************                             *********************
;******************            STD-85           *********************
;******************      DIAGNOSTIC TOOLBOX     *********************
;******************              &              *********************
;******************        CONFIDENCE TEST      *********************
;******************                             *********************
;********************************************************************
;********************************************************************
;
;    PROGRAM WRITTEN BY CRAIG ANDREWS, 2022
;    COPYRIGHT 2022 (C) OF CRAIG ANDREWS ALL RIGHTS RESERVED
;
;
;********************************************************************
;********************************************************************

;WORK IN PROGRESS--
;PORTED FROM SBC-85 CONFIDENCE TEST



;********************************************************************
;*********************        VERSION       *************************
;*********************       V1.V2.V3       *************************
;*********************     ALL ONE DIGIT    *************************
;********************************************************************
V1	EQU	"0"		;VERSION	
V2	EQU	"0"		;TENTHS
V3	EQU	"6"		;HUNDRETHS


;********************************************************************
;*************************** INCLUDES *******************************
;*****************  ALSO SEE AT END OF FILE  ************************
;********************************************************************
	INCL	"ASCII.DEF"
;	INCL	"OPCODES.DEF"



;********************************************************************
;********************************************************************
;************ STD-85  HARDWARE SPECIFIC DEFINITIONS **************
;********************************************************************
;********************************************************************

;********************************************************************
;****************** MISCELLANEOUS DEFINITIONS ***********************
;********************************************************************
;ASSEMBLER DIRECTIVES


;********************************************************************
;************* SID / SOD SERIAL PORT MASKS, DELAYS ******************
;********************************************************************
;NORMAL SERIAL TIMER LOADS WHEN NOT USING DELAY SUBROUTINE
IBTIM	EQU	51 		;INPUT INTER-BIT TIME DELAY 2400 BAUD
OBTIM	EQU	IBTIM 		;OUPUT INTER-BIT TIME DELAY
TIM4	EQU	4*IBTIM		;4 BIT TIME DELAY
WAIT	EQU	IBTIM/2		;DELAY UNTIL READY TO SAMPLE BITS

;SERIAL TIMER LOADS WHEN DELAY SUBROUTINE THAT ALSO LOOKS FOR INPUT CHARACTER
IBTIMD	EQU	28 		;INPUT INTER-BIT TIME DELAY 2400 BAUD
OBTIMD	EQU	IBTIMD 		;OUPUT INTER-BIT TIME DELAY
TIM4D	EQU	4*IBTIMD	;4 BIT TIME DELAY
WAITD	EQU	IBTIMD/2	;DELAY UNTIL READY TO SAMPLE BITS


SSTRT	EQU	80H		; SHIFTED SOD ENABLE
STOPB	EQU	0C0H		; STOP BIT (INVERTED)
STRT	EQU	40H		; UNSHIFTED START BIT (INVERTED)
SBITS	EQU	8		;SERIAL BITS TO SEND OR RECEIVE



;********************************************************************
;******************   MEMORY ADDRESS MAPPING  ***********************
;********************************************************************
OKBS		EQU	0400H		;ONE K BLOCK SIZE


M3_Dfalt	EQU	00000H		;M3 16K ROM 0000-3FFF
PL7702A1	EQU	04000H		;PRO-LOG 7702A 16K RAM 4000-7FFF
PL7702A2	EQU	08000H		;PRO-LOG 7702A 16K RAM 8000-BFFF
M1_Dfalt	EQU	0C000H		;M1 6264 RAM 8K C000-DFFF
OneK_Dfalt	EQU	0E000H		;One K Block E000-FFFF
M2_Dfalt	EQU	0A000H		;M2 Default Mapping Base Address


i8155_DBlock	EQU	0		;8155 1K block default selection
OBP_DBlock	EQU	7		;OBP 1K block default selection
i8155_Dfalt	EQU	OneK_Dfalt + i8155_DBlock*OKBS	;8155 Default Base Address

M3_Alt		EQU	00000H		;M3 Alternate Mapping Base Address
M1_Alt		EQU	0C000H		;M1 6264 RAM
OneK_Alt	EQU	0E000H		;1K block Alternate Mapping Base Address
;M2_Alt		EQU			;M2 Alternate Mapping Base Address


i8155_ABlock	EQU	0		;8155 1K block alternate selection
OBP_ABlock	EQU	7		;OBP 1K block alternate selection
i8155_Alt	EQU	OneK_Alt + i8155_ABlock*OKBS	;8155 alternate Base Address



;NOT SWAPPING MEMORY MAPS, SO SIMPLIFY TO STATIC ADDRESS NAMES

i8155		EQU	i8155_Dfalt	;8155 (STATIC) BASE ADDRESS
BO_BASE_ROM	EQU	M3_Dfalt
TO_BASE_ROM	EQU	BO_BASE_ROM+7FFFH
BO_EE		EQU	M2_Dfalt
TO_EE		EQU	BO_EE+3FFFH

BO_6264	EQU	M1_Dfalt
TO_6264	EQU	BO_6264+ 1FFFH
BO_8155	EQU	i8155
TO_8155	EQU	BO_8155 +0FFH


;********************************************************************
;*********************   PORT ADDRESSES    **************************
;********************************************************************
i8155D_CS	EQU	HIGH(i8155_Dfalt)	;8155 Default COMMAND STATUS REGISTER
i8155D_A	EQU	i8155D_CS+1		;8155 Default PORT A
i8155D_B	EQU	i8155D_CS+2		;8155 Default PORT B
i8155D_C	EQU	i8155D_CS+3		;8155 Default PORT C
i8155D_TLSB	EQU	i8155D_CS+4		;8155 Default TIMER LSB
i8155D_TMSB	EQU	i8155D_CS+5		;8155 Default TIMER LSB

i8155A_CS	EQU	HIGH(i8155_Alt)		;8155 Alternate Map COMMAND STATUS REGISTER
i8155A_A	EQU	i8155A_CS+1		;8155 Alternate Map PORT A
i8155A_B	EQU	i8155A_CS+2		;8155 Alternate Map PORT B
i8155A_C	EQU	i8155A_CS+3		;8155 Alternate Map PORT C
i8155A_TLSB	EQU	i8155A_CS+4		;8155 Alternate Map TIMER LSB
i8155A_TMSB	EQU	i8155A_CS+5		;8155 Alternate Map TIMER LSB

OBP_Dfalt	EQU	HIGH (OneK_Dfalt+ OBP_DBlock*OKBS)	;Onboard Port Default Mapping Address
OBP_Alt	EQU	HIGH (OneK_Alt+ OBP_ABlock*OKBS)	;Onboard Port Alternate Mapping Address


;NOT SWAPPING MEMORY MAPS, SO SIMPLIFY TO STATIC ADDRESS NAMES
i8155_CS	EQU	HIGH(i8155_Dfalt)	;8155 Static COMMAND STATUS REGISTER
i8155_A	EQU	i8155D_CS+1		;8155 Static PORT A
i8155_B	EQU	i8155D_CS+2		;8155 Static PORT B
i8155_C	EQU	i8155D_CS+3		;8155 Static PORT C
i8155_TLSB	EQU	i8155D_CS+4		;8155 Static TIMER LSB
i8155_TMSB	EQU	i8155D_CS+5		;8155 Static TIMER LSB
OBP		EQU	OBP_Dfalt		;OnBoardPort Static Address


PL7303DP	EQU	00H			;Pro-Log 7307 keypad display data port
PL7303CP	EQU	PL7303DP+1		;Pro-Log 7307 keypad display control port



;********************************************************************
;******** LATCHED INPUTS & OUTPUTS PORT DEFINITIONS & MASKS *********
;********************************************************************



;********************************************************************
;*************** 8155 PORT DEFINITIONS & MASKS *****************
;********************************************************************
i8155_OOO	EQU	00001111B	;PORT A OUTPUT, PORT B OUTPUT, PORT C OUTPUT
i8155_0II	EQU	00000001B	;PORT A OUTPUT, PORT B INPUT, PORT C INPUT
i8155_IOO	EQU	00000010B	;PORT A INPUT, PORT B OUTPUT, PORT C INPUT
i8155_III	EQU	00000000B	;PORT A IN, PORT B IN, PORT C IN



;********************************************************************
;*************** 8155 TIMER PORT DEFINITIONS & MASKS ****************
;********************************************************************


;********************************************************************
;***********   RESTART AND INTERRUPT BRANCH ADDRESSES  **************
;********************************************************************

RST0		EQU	0*8
RST1		EQU	1*8
RST2		EQU	2*8
RST3		EQU	3*8
RST4		EQU	4*8
TRAP		EQU	4*8+4
RST5		EQU	5*8
RST5p5		EQU	5*8+4
RST6		EQU	6*8
RST6p5		EQU	6*8+4
RST7		EQU	7*8
RST7p5		EQU	7*8+4


;********************************************************************
;**********************  ROM RESERVATIONS  **************************
;********************************************************************

	ORG	TO_BASE_ROM-05H
BMSG_VERSION#	DB	V1,".",V2,".",V3,ETX	;BASE ROM VERSION NUMBER. 5 CHARACTER LIMIT+ETX


;********************************************************************
;***************          RAM RESERVATIONS           ****************
;********************************************************************
	ORG	BO_6264			;BASE OF 6264 RAM

	ORG	BO_8155			;BASE OF 8155 RAM

OBP_Value		DB	1		;OnBoard Port Output Value
BUFFER1:		DS	2		;BUFFER
BUFFER2:		DS	2		;BUFFER
BUFFER3:		DS	10		;BUFFER
BUFFER4:		DS	16		;BUFFER
STOP_FLAG:		DS	1		;FLAG FOR USER STOP TEST
RUNTIME:		DS	50		;SPACE FOR RUNTIME CODE
INPBUFF:		DS	50		;INPUT CHARACTER BUFFER
IPB_LEN		EQU	$-INPBUFF	;INPUT BUFFER LENGTH
BP_TABLE_LEN	EQU	10D		;ALLOWED NUMBER OF BREAKPOINTS
;BP_TABLE:		DS	3*BP_TBL_LEN	;BREAKPOINT TABLE

BP_TABLE:		DS	3	;BREAKPOINT TABLE

USER_RAM:		DS	50	;USER RAM IN THIS DEVICE BEGINS HERE
StackSize		SET	TO_8155-$	;available stack size
STACK:		EQU	TO_8155	;TOP OF STACK IS HERE

;alternate stacks for memory testing routines
STACK_6264:	EQU	TO_6264
STACK_8155:	EQU	TO_8155


;********************************************************************
;********************************************************************
;******************                             *********************
;******************        START OF CODE        *********************
;******************                             *********************
;********************************************************************
;********************************************************************
	ORG	RST0	;CODE STARTS HERE
	DI
	LXI	SP,STACK	;SET THE STACK
	JMP	CONTINUE	;CONTINUE AFTER INTERRUPT AND RESTARTS

	ORG	RST1
	JMP	CONTINUE	;CONTINUE AFTER INTERRUPT AND RESTARTS

	ORG	RST2		;BREAKPOINT HIT
	JMP	BP_HIT

	ORG	RST3		;BREAKPOINT RESTORE
	JMP	BP_RESTORE

	ORG	RST5p5
	ORG	RST6
	ORG	RST6p5
	ORG	RST7
	ORG	RST7p5

;********************************************************************
;********************************************************************
;*******************                       **************************
;*******************  DIAGNOSTIC TOOLBOX   **************************
;*******************            &          **************************
;*******************     CONFIDENCE TEST   **************************
;*******************        START OF       **************************
;*******************          CODE         **************************
;*******************                       **************************
;********************************************************************
;********************************************************************
;NOTE: PROMPT ADDRESS IS PUSHED ONTO STACK PRIOR TO
;      CHANGING PC TO BRANCH SO ALL BRANCHES (EXCEPT CMD_C AND CT_D)
;      CAN USE RET TO POP ADDRESS INTO PC STACK IS RESET SO THOSE
;      THOSE THAT DO DIRTY THINGS CAN JUMP BACK TO CMD_PROMPT

CONTINUE:

;FILL BREAKPOINT TABLE, ZERO TWO ADDRESS BYTES AND FILL ONE OPCODE BYTE  
	MVI	B,BP_TABLE_LEN	;NUMBER OF BREAKPOINTS ALLOWED
	LXI	H,BP_TABLE	;FILL BREAKPOINT TABLE VALUES
	XRA	A		;CLEAR ACCUMULATOR
CLR_BPT:	
	MOV	M,A		;ZERO ADDRESS LOW BYTE
	INX	H
	MOV	M,A		;ZERO ADDRESS HIGH BYTE
	INX	H
	MVI	M,08H		;FILL WITH INVALID OPCODE
	INX	H		;POINT TO NEXT
	DCR	B		;ONE DONE
	JNZ	CLR_BPT		;DO UNTIL FILLED


	LXI	H,BANNER	;LOAD BANNER ADDRESS
	CALL	SENDSTRING	;SEND TO TERMINAL
CMD_PROCESSOR:			;READ TERMINAL AND BRANCH TO FUNCTION
	DI
	LXI	SP,STACK	;SET THE STACK



;********************************************************************
;************  DIAGNOSTIC TOOLBOX COMMAND PROCESSOR  ****************
;********************************************************************
	CALL	NEWLINE		
	CALL	CMD_V		;SEND VERSION INFO
	CALL	CMD_H		;SEND HELP
	CALL	NEWLINE
	CALL	NEWLINE

CMD_PROMPT:
	LXI	SP,STACK	;FRESH START AFTER SOME NASTY TESTS SO RESET THE STACK
	CALL	PROMPT		;SEND PROMPT
		
CMD_LOOP:			;
	CALL	CI		;GET COMMAND CHARACTER
	CALL	CO		;ECHO TO USER
	CALL	TOUPPER		;CHANGE RESULT TO UPPER CASE
	CALL	NEWLINE		;NEW LINE TO DISPLAY RESULT
	CPI	ENQ		
	SUI	"0"		;SUBTRACT OFF LOWEST COMMAND
	JM	CMD_ERROR	;IF BELOW LOWEST CHARACTER, SEND ERROR
	CPI	CMD_TBL_LEN	;COMPARE TO THE NUMBER OF VALID COMMANDS
	JNC	CMD_ERROR	;IF GREATER, SEND ERROR
	LXI	H,CMD_PROMPT	;PUT COMMAND PROCESSOR ADDRESS INTO HL AND
	PUSH	H		;PUSH ONTO STACK FOR A CLEAN RETURN
	LXI	H,CMD_TBL	;LOAD BASE OF COMMAND TABLE
	MVI	B,00H		;CLEAR B
	MOV	C,A		;COPY COMMAND VALUE INTO BC TO CREATE OFFSET VALUE
	DAD	B		;ADD OFFSET TO BASE TO POINT TO BRANCH ADDRESS
	DAD	B		;ADDRESSES ARE 2 BYTES EACH SO ADD TWICE
	DAD	B		;COMMAND USE IS ALSO IN TABLE, SO ADD 4X
	DAD	B
	MOV	A,M		;LSB OF BRANCH ADDRESS FROM COMMAND TABLE INTO A
	INX	H		;INCREMENT MEMORY POINTER TO MSB
	MOV	H,M		;PUT MSB OF BRANCH ADDRESS INTO INTO H
	MOV	L,A		;DONE USING M POINTER SO PUT LSB INTO L	
	PCHL			;HL NOW HAS ADDRESS OF BRANCH, MOVE INTO PC TO CONTINUE AT BRANCH




;********************************************************************
;*************** DIAGNOSTIC TOOLBOX COMMAND TABLE *******************
;********************************************************************
;  NAME: CMDTBL
;  DESCRIPTION: EACH TABLE ENTRY MUST HAVE TWO COMPONENTS:
;    COMMAND BRANCH LABEL AND COMMAND USE LABEL
;    IF COMMAND IS UNUSED, USE CMD_ERROR FOR COMMAND LABEL AND USE
;    CMD__H FOR COMMAND USE
;********************************************************************
CMD_TBL:	
	DW	CMD_ERROR	;0
CMD_USE_TBL:
	DW	CMD__USE	
	DW	CMD_ERROR	;1
	DW	CMD__USE	
	DW	CMD_ERROR	;2
	DW	CMD__USE	
	DW	CMD_ERROR	;3
	DW	CMD__USE	
	DW	CMD_ERROR	;4
	DW	CMD__USE	
	DW	CMD_ERROR	;5
	DW	CMD__USE	
	DW	CMD_6		;6-- 6264 RAM TEST
	DW	CMD_6_USE	
	DW	CMD_7		;7-- 7303 KEYBOARD / DISPLAY TEST
	DW	CMD_7_USE	
	DW	CMD_8		;8-- 8155 RAM TEST
	DW	CMD_8_USE	
	DW	CMD_ERROR	;9
	DW	CMD__USE	
	DW	CMD_ERROR	;: 
	DW	CMD__USE	
	DW	CMD_ERROR	;;
	DW	CMD__USE	
	DW	CMD_ERROR	;<
	DW	CMD__USE	
	DW	CMD_ERROR	;=
	DW	CMD__USE	
	DW	CMD_ERROR	;>
	DW	CMD__USE	
	DW	CMD_H		;?-- HELP
	DW	CMD_?_USE
	DW	CMD_ERROR	;@
	DW	CMD__USE	
	DW	CMD_ERROR	;A
	DW	CMD__USE	
	DW	CMD_B		;B-- BREAKPOINT
	DW	CMD_B_USE	
	DW	CMD_C		;C-- COPY MEMORY BLOCK
	DW	CMD_C_USE	
	DW	CMD_D		;D-- DUMP MEMORY
	DW	CMD_D_USE	
	DW	CMD_E		;E-- EDIT MEMORY VALUE
	DW	CMD_E_USE	
	DW	CMD_F		;F-- FILL MEMORY
	DW	CMD_F_USE	
	DW	CMD_G		;G-- GO
	DW	CMD_G_USE	
	DW	CMD_H		;H-- HELP
	DW	CMD_H_USE
	DW	CMD_I		;I-- INPUT FROM PORT
	DW	CMD_I_USE	
	DW	CMD_ERROR	;J
	DW	CMD__USE	
	DW	CMD_ERROR	;K
	DW	CMD__USE	
	DW	CMD_L		;L-- LIST AND READ MEMORY LOCATIONS
	DW	CMD_L_USE	
	DW	CMD_M		;M-- MAP RAM
	DW	CMD_M_USE	
	DW	CMD_ERROR	;N
	DW	CMD__USE	
	DW	CMD_O		;O-- OUTPUT USER VALUE TO SELECTED PORT
	DW	CMD_O_USE	
	DW	CMD__USE	;P-- 
	DW	CMD__USE	
	DW	CMD_ERROR	;Q--
	DW	CMD__USE	
	DW	CMD_R		;R-- RAM TEST
	DW	CMD_R_USE	
	DW	CMD_S		;S-- STICKY RAM BIT TEST
	DW	CMD_S_USE	
	DW	CMD_T		;T-- TTY TEST
	DW	CMD_T_USE	
	DW	CMD_ERROR	;U-- 
	DW	CMD__USE	
	DW	CMD_V		;V-- VERSION DISPLAY
	DW	CMD_V_USE	
	DW	CMD_W		;W-- WRITE TO A LIST OF MEMORY LOCATIONS
	DW	CMD_W_USE	
	DW	CMD_ERROR	;X
	DW	CMD__USE	
	DW	CMD_ERROR	;Y
	DW	CMD__USE	
	DW	CMD_Z		;Z-- (ZERO) JUMP RESTART
	DW	CMD_Z_USE	
CMD_TBL_LEN	EQU	($-CMD_TBL)/4



CMD_ERROR:
	MVI	A,BELL		;LOAD BELL
	CALL	CO		;SEND TO TERMINAL
	MVI	A,"?"
	CALL	CO
	JMP	CMD_PROMPT



;********************************************************************
;********************************************************************
;**************************                **************************
;**************************    BRANCHES    **************************
;**************************                **************************
;********************************************************************
;********************************************************************
;NOTE: EACH BRANCH MUST HAVE A USE INSTRUCTION STRING WITH THE LABEL
;      CMD_?_USE WHERE ? IS THE COMMAND.  THE STRING MUST END WITH
;      THE ETX CHARACTER.  "H" COMMAND EXAMPLE:
;      CMD_H_USE:	DB	"H -- DISPLAY (H)ELP", CR, LF, ETX
;
;NOTE: ADDRESS OF CMD_LOOP WAS PUSHED ONTO STACK BY COMMAND PROCESSOR
;      SO ALL BRANCHES MUST USE RET TO POP COMMAND LOOP ADDRESS INTO PC


;********************************************************************
;************************  6264 CHECK BRANCH  ***************************
;  NAME: CMD_6
;  FUNCTION: PERFORMS CHECK OF SYSTEM RAM
;  INPUTS: NONE
;  OUTPUTS: 
;  USER IO: PROVIDES STATUS TO USER VIA SERIAL PORT. ENDS WITH 
;    BEGINNING AND ENDING LOCATION OF RAM.
;    DISPLAYS TEST NUMBER TO USER VIA SERIAL PORT
;  DESTROYS: A, BC, DE, HL, SP
;  CALLS: NEWLINE, SENDSTRING, SEND_DE, SEND_HL, CO
;
;  DESCRIPTION:
;    RAMCHK IDENTIFIES THE BOTTOM OF RAM TO USER.
;    IT THEN STARTS AT THE BOTTOM OF RAM AND PUTS PATTERN INTO MEMORY LOCATION
;    TESTS FOR MATCH, THEN FLIPS PATTERN AND RETESTS.  IF LOCATION PASSES IT
;    MOVES UP ONE MEMORY LOCATION
;    RAM TEST CONTINUES UNTIL INTERRUPTED WITH ANOTHER KEYSTROKE BY USER
;     ####### WARNING #####
;    RAMCHK PRETTY MUCH DESTORYS EVERYTHING.
;    FOR THIS REASON THERE ARE PERIODS
;    WHERE THERE SHOULD BE NO CALLS TO SUBROUTINES BECAUSE THE STACK MAY
;    BE DESTROYED.  
;********************************************************************


CMD_6:
	MVI	A,0FFH		;RESET STOP FLAG BUFFER WHICH IS USED TO 
	STA	STOP_FLAG	;  DETECT IF THERE WAS A CHARACTER INPUT
	LXI	D,0000H		;CLEAR DE PAIR
	LXI	SP,STACK_8155	;USE THE 8155 STACK
CMD_6_LOOP:
	INX	D		;INCREMENT TEST COUNT NUMBER
	LXI	H,BO_6264
	SHLD	BUFFER2
	CALL	R_TEST		;DO THE TEST UNTIL FIRST FAIL
	JMP	CMD_6_LOOP

CMD_6_USE:	DB	"6 -- (6)264 RAM TEST", CR, LF, ETX


;********************************************************************
;*****************  7303 Keypad / Display Test  *********************
;  NAME: CMD_7
;  FUNCTION: Tests Pro-Log 7303 keypad & display STD card
;  INPUTS: NONE
;  OUTPUTS: 
;  USER IO:
;  DESTROYS: A, BC, DE, HL, SP
;  CALLS: NEWLINE, SENDSTRING, SEND_DE, SEND_HL, CO
;
;  DESCRIPTION:
;********************************************************************
SCANBUFFER	SET	BUFFER3

CMD_7:
	LXI	H,CMD_7_SMSG1	;MSG TO USER HOW TO USE
	CALL	SENDSTRING
	LXI	H,INPBUFF		;INPUT BUFFER, HL IS FOR OUTGOING CHARACTERS
	LXI	D,INPBUFF		;INPUT BUFFER, DE IS FOR INCOMING CHARACTERS
	MVI	M,ETX			;PUT ETX IN BUFFER


CMD_7_LOOP:
	CALL	CICHECK		;IS THERE AN INPUT CHARACTER?
	ORA	A			;TEST ACCUMULATOR
	CNZ	CMD_7_INCOMING	; SOMETHING IS THERE, DEAL WITH IT

	PUSH	H			;SAVE HL FOR KEYPAD SCAN
	LXI	H,SCANBUFFER	;BUFFER FOR KEYBOARD SCAN RESULTS
	CALL	PL7303_READ		;READ 7307 KEYS & SWITCHES
	POP	H			;RESTORE H
	ORA	A			;WERE ANY KEYS PRESSED?
	JZ	CMD_7_NOKEYS	; NO, CONTINUE
	LXI	H,SCANBUFFER	; YES, RELOAD SCAN RESULT BUFFER
	MVI	B,00H			;START ON FAR RIGHT POSITION
CMD_7_KEYPATTERN:
	MOV	A,M			;GET COLUMN RESULT
	CALL	TOASCIIL		;CONVERT HIGH NIBBLE TO ASCII
	CALL	PL7303_DISPLAY	;DISPLAY VALUE
	INR	B			;MOVE OVER POSITION TO RIGHT
	MOV	A,M			;GET RESULT AGAIN
	CALL	TOASCIIH		;CONVERT LOW NIBBLE TO ASCII
	CALL	PL7303_DISPLAY	;DISPLAY VALUE
	INX	H			;NEXT COLUMN IN BUFFER
	INR	B			;MOVE OVER DISPLAY POSITION TO RIGHT
	MOV	A,B			;GET DISPLAY POSITION
	CPI	08D			;DONE
	JNZ	CMD_7_KEYPATTERN	; NO, DO FOR ALL COLUMNS
	LXI	H,INPBUFF		; YES,RESET DISPLAY BUFFER POINTER
	JMP	CMD_7_LOOP		;LOOP

CMD_7_NOKEYS:	
	MOV	A,M			;GET STARTING CHARACTER FROM BUFFER
	CPI	ETX			;IS IT AN END OF TEXT?
	JZ	CMD_7_R&L		; YES, RESET AND LOOP
	CALL	PL7303_FILL		; NO, THEN FILL DISPLAY STARTING AT HL
	INX	H			;INCREMENT TO NEXT CHARACTER IN BUFFER
	JMP	CMD_7_LOOP		;LOOP

CMD_7_R&L:
	LXI	H,INPBUFF		;DONE WITH STRING, MOVE POINTER TO BEGINNING OF BUFFER
	JMP	CMD_7_LOOP		;THEN LOOP
	

CMD_7_INCOMING:
	LXI	H,INPBUFF		;RESET DISPLAY BUFFER POINTER TO BEGINNING
	CALL	CO
	CPI	00H			;IS ANYTHING THERE?
	RZ				; NO, JUST RETURN
	CPI	CR			;IS CI A CARRIAGE RETURN?
	JNZ	CMD_7_NOTCR		; NO, JUMP TO NEXT TEST
	LXI	D,INPBUFF		; YES, RESET INCOMING BUFFER POINTER TO BEGINNING
	CALL	NEWLINE		;NEXT LINE ON TERMINAL
	RET				; AND RETURN BECAUSE WE ARE STARTING OVER
CMD_7_NOTCR:
	CPI	ESC			;IS IT AN ESCAPE?
	JNZ	CMD_7_IN_TESTED	; NO, CONTINUE
	POP	H			; YES, THIS CALL RETURN ADDRESS TO BIT BUCKET
	RET				; THEN RETURN TO MAIN CALLING PROGRAM

CMD_7_IN_TESTED:			;ADD INPUT CHARACTER TO BUFFER
	XCHG				;GET FILL POINTER FROM DE
	MOV	M,A			;PUT CHARACTER INTO BUFFER
	INX	H			;POINT TO NEXT BUFFER LOCATION
	MVI	M,ETX			;PUT ETX IN NEXT BUFFER LOCATION
	XCHG				;FILL POINTER BACK INTO DE
	RET				;RETURN

	
CMD_7_USE:	DB	"7 -- (7)303 KEYPAD / DISPLAY TEST", CR, LF, ETX
CMD_7_SMSG1:	DB	"ENTERED CHARACTERS WILL BE DISPLAYED ON 7303.",CR,LF
CMD_7_SMSG2:	DB	"DEPRESSED KEYPAD BUTTON WILL BE DISPLAYED AS R:C ",CR,LF
CMD_7_SMSG3:	DB	"WITH LOWER LEFT BUTTON AS 0:0 .",CR,LF
CMD_7_SMSG4:	DB	"ROCKERS DISPLAYED WITH < AND/OR > .",CR,LF
CMD_7_SMSG5:	DB	"ENTER ESC TO QUIT",CR,LF, ETX

;********************************************************************
;************************  8155 CHECK BRANCH  ***************************
;  NAME: CMD_8
;  FUNCTION: PERFORMS CHECK OF SYSTEM RAM
;  INPUTS: NONE
;  OUTPUTS: 
;  USER IO: PROVIDES STATUS TO USER VIA SERIAL PORT. ENDS WITH 
;    BEGINNING AND ENDING LOCATION OF RAM.
;    DISPLAYS TEST NUMBER TO USER VIA SERIAL PORT
;  DESTROYS: A, BC, DE, HL, SP
;  CALLS: NEWLINE, SENDSTRING, SEND_DE, SEND_HL, CO
;
;  DESCRIPTION:
;    RAMCHK IDENTIFIES THE BOTTOM OF RAM TO USER.
;    IT THEN STARTS AT THE BOTTOM OF RAM AND PUTS PATTERN INTO MEMORY LOCATION
;    TESTS FOR MATCH, THEN FLIPS PATTERN AND RETESTS.  IF LOCATION PASSES IT
;    MOVES UP ONE MEMORY LOCATION
;    NOTE THAT THE 8155 ADDRESS DECODER WILL ALLOW FOLDBACK, SO TESTS TO 47FFH
;    RAM TEST CONTINUES UNTIL INTERRUPTED WITH ANOTHER KEYSTROKE BY USER
;     ####### WARNING #####
;    RAMCHK PRETTY MUCH DESTORYS EVERYTHING.
;    FOR THIS REASON THERE ARE PERIODS
;    WHERE THERE SHOULD BE NO CALLS TO SUBROUTINES BECAUSE THE STACK MAY
;    BE DESTROYED.  
;********************************************************************


CMD_8:
	MVI	A,0FFH		;RESET STOP FLAG BUFFER WHICH IS USED TO 
	STA	STOP_FLAG	;  DETECT IF THERE WAS A CHARACTER INPUT
	LXI	D,0000H		;CLEAR DE PAIR
	LXI	SP,STACK_6264	;USE THE 6264 FOR STACK
CMD_8_LOOP:
	INX	D		;INCREMENT TEST COUNT NUMBER
	LXI	H,BO_8155
	SHLD	BUFFER2
	CALL	R_TEST		;DO THE TEST UNTIL FIRST FAIL
	JMP	CMD_8_LOOP

CMD_8_USE:	DB	"8 -- (8)155 RAM TEST", CR, LF, ETX







;********************************************************************
;************************   BREAKPOINT MANAGER   ********************
;********************************************************************
;  NAME: CMD_B
;  FUNCTION: 
;  INPUTS:
;  OUTPUTS:
;  USER IO: 
;  DESTROYS:
;  CALLS:
;  DESCRIPTION: 
;********************************************************************
CMD_B:	
	LXI	H,CMD_B_SET	;MSG TO USER FOR BREAKPOINT ADDRESS
	CALL	SENDSTRING	
	CALL	GETHEXWORD	;BREAKPOINT ADDRESS RETURNED IN HL
	JZ	CMD_PROMPT	;USER SHORTED THE ANSWER, ABORT
	SHLD	BP_TABLE	;STORE BP ADDRESS IN TABLE
	MOV	A,M		;RETREIVE USER OPCODE
	STA	BP_TABLE+2	;STORE BP OPCODE
	MVI	M,iRST2		;REPLACE USER INSTRUCTION WITH RESTART
	JMP	CMD_PROMPT	;DONE HERE, RETURN TO COMMAND PROCESSOR	


BP_HIT:				;BREAKPOINT HIT HANDLER

	XTHL			;GET RETURN ADDRESS
	DCX	H		;BACK UP TO WHERE OPCODE WAS
	XTHL			;PUT RETURN ADDRESS BACK

	PUSH	PSW		;SAVE ALL REGISTERS
	PUSH	H
	PUSH	D
	PUSH	B
	PUSH	PSW		;PUT PSW INTO BC PAIR
	POP	B

	LHLD	BP_TABLE	;LOAD HL WITH BREAKPOINT ADDRESS
	LDA	BP_TABLE+2	;GET ORIGINAL OPCODE
	MOV	M,A		;RESTORE ORIGINAL OPCODE

	LXI	H,CMD_B_PC	;LOAD PC MESSAGE
	CALL	SENDSTRING	
	LHLD	BP_TABLE	;NOT QUITE TRUE, BUT INTENTIONS ARE GOOD
	CALL	SEND_HL		; WHERE PC WILL BE WHEN WE ARE ALL DONE
	
	LXI	H,CMD_B_SP	;LOAD PC MESSAGE
	CALL	SENDSTRING
	LXI	H,10D		;HL=NUMBER OF THINGS BREAKPOINT HAS PUSHED ONTO STACK
	DAD	SP		;ADD STACK POINTER TO HL TO GET STACK BEFORE BREAKPOINT	
	CALL	SEND_HL		; SEND STACK POINTER

	LXI	H,CMD_B_A	;LOAD ACCUMULATOR MESSAGE
	CALL	SENDSTRING	
	MOV	A,B		;RESTORE ACCUMULATOR
	CALL	HO		;DISPLAY ACCUMULATOR

	LXI	H,CMD_B_PSW	;LOAD PSW MESSAGE
	CALL	SENDSTRING
	MOV	A,C		;PSW INTO A
	CALL	HO

	LXI	H,CMD_B_BC	;LOAD BC MESSAGE
	CALL	SENDSTRING
	POP	B		;RESTORE BC
	CALL	SEND_BC		;SEND BC PAIR

	LXI	H,CMD_B_DE	;LOAD DE MESSAGE
	CALL	SENDSTRING
	POP	D		;RESTORE DE
	CALL	SEND_DE		;SEND DE PAIR

	LXI	H,CMD_B_HL	;LOAD HL MESSAGE
	CALL	SENDSTRING
	POP	H		;RESTORE HL
	CALL	SEND_HL		;SEND HL PAIR
	CALL	NEWLINE

	POP	PSW		;RESTORE PSW
	RET			;TAKE UP FROM BREAKPOINT OPCODE



CMD_B_USE:	DB	"B -- (B)REAKPOINT CONFIGURE", CR, LF, ETX
CMD_B_SET:	DB	"ENTER BREAKPOINT HEX ADDRESS--", ETX
CMD_B_A		DB	", A:",ETX
CMD_B_PSW	DB	", PSW:",ETX
CMD_B_BC	DB	", BC:",ETX
CMD_B_DE	DB	", DE:",ETX
CMD_B_HL	DB	", HL:",ETX
CMD_B_SP	DB	", SP:",ETX
CMD_B_PC	DB	CR,LF,"PC:",ETX


;********************************************************************
;************************  COPY MEMORY BRANCH  ***************************
;  NAME: CMD_C
;  FUNCTION: COPYS USER SPECIFIED MEMORY BLOCK TO ANOTHER BLOCK IN RAM
;  INPUTS: NONE
;  OUTPUTS: DESTINATION MEMORY BLOCK FILLED
;  USER IO: REQUESTS START AND END OF SOURCE BLOCK, START OF DESTINATION, AND
;	CONFIRMATION
;  DESTROYS: A, F/F, BC, DE, HL
;  CALLS: SENDSTRING, GETHEXWORD, NEWLINE, CI, SEND_DE, SEND_HL
;
;  DESCRIPTION:
;********************************************************************
CMD_C:
	LXI	H,CMD_C_SMSG	;MSG TO USER FOR START ADDRESS
	CALL	SENDSTRING
	CALL	GETHEXWORD	;PUT STARTING ADDRESS INTO HL
	XCHG			;DE=START
	LXI	H,CMD_C_EMSG	;ASK FOR ENDING ADDRESS
	CALL	SENDSTRING
	CALL	GETHEXWORD	;PUT ENDING ADDRESS INTO HL
	MOV	B,H		;BC=END, DE=START
	MOV	C,L
	LXI	H,CMD_C_TOMSG	;ASK FOR DESTINATION ADDRESS
	CALL	SENDSTRING
	CALL	GETHEXWORD	;PUT DESTINATION ADDRESS INTO HL
	PUSH	H		;BC=END, DE=START, STACK=DESTINATION
	CALL	NEWLINE

	LXI	H,CMD_C_START	;ECHO ADDRESSES BACK TO USER
	CALL	SENDSTRING
 	CALL	SEND_DE		;REPEAT BACK TO USER OUR UNDERSTANDING OF START ADDRESS
	LXI	H,CMD_C_ENDING	;
	CALL	SENDSTRING
	MOV	H,B		;COPY END ADDRESS TO HL
	MOV	L,C
 	CALL	SEND_HL		;BC=END, DE=START, HL=END, STACK=DESTINATION
	LXI	H,CMD_C_INTO	;ECHO DESTINATION ADDRESS
	CALL	SENDSTRING
	POP	H		;BC=END, DE=START, HL=DESTINATION
 	CALL	SEND_HL		;SEND DESTINATION ADDRESS
	XCHG			;AFTER: BC=END, DE=DESTINATION, HL=START
 	CALL	NEWLINE
	PUSH	H		;AFTER: BC=END, DE=DESTINATION, STACK=START
	LXI	H,CMD_C_YN	;CONFIRM
	CALL	SENDSTRING
	CALL	CI		;GET USER RESPONSE
	CALL	CO
	CPI	"Y"		;COMPARE TO "Y"
	JNZ	CMD_PROMPT	;NOT A Y, SO DONE HERE, RETURN TO COMMAND PROCESSOR
	POP	H		;AFTER: BC=END, DE=DESTINATION, HL=START
	DCX	H		;COMPENSATE FOR FIRST INX IN LOOP
CMD_C_COPY:			;BC=END, DE=DESTINATION, HL=SOURCE
	INX	H		;MOVE M-POINTER TO NEXT SOURCE
	MOV	A,M		;GET A BYTE FROM SOURCE
	XCHG			;SWAP M-POINTER TO DESTINATION
	MOV	M,A		;SAVE THE BYTE TO DESTINATION BLOCK
	INX	H		;M-POINTER TO NEXT DESTINATION
	XCHG			;SWAP M-POINTER BACK TO SOURCE
	MOV	A,H		;GET SOURCE HIGH BYTE OF LAST ONE DONE
	CMP	B		;DOES IT MATCH END?
	JNZ	CMD_C_COPY	; NO, MORE TO DO SO CONTINUE WITH MOVE
	MOV	A,L		; YES, SO NOW CHECK LOW BYTE, FIRST MOVE TO A
	CMP	C		;DOES IT MATCH END LOW BYTE?
	JNZ	CMD_C_COPY	; NO, DO MORE

CMD_C_DONE:			; YES, WE ARE DONE
	LXI	H,CMD_C_DONEMSG	;DONE MESSAGE
	CALL	SENDSTRING	;SEND MESSAGE TO USER
	JMP	CMD_PROMPT	;RETURN TO COMMAND PROMPT


CMD_C_USE:	DB	"C -- (C)OPY MEMORY BLOCK (STARTING)-(ENDING) INTO (DESTINATION)", CR, LF, ETX
CMD_C_SMSG	DB	"SOURCE HEX STARTING ADDRESS? (XXXX)-- ", ETX
CMD_C_EMSG	DB	CR,LF,"SOURCE HEX ENDING ADDRESS? (XXXX)-- ", ETX
CMD_C_TOMSG	DB	CR,LF,"DESTINATION HEX ADDRESS? (XXXX)", ETX
CMD_C_START	DB	CR,LF,"COPY MEMORY BLOCK FROM ", ETX
CMD_C_ENDING	DB	" TO ", ETX
CMD_C_INTO	DB	" INTO MEMORY BLOCK BEGINNING AT ",ETX
CMD_C_YN	DB	CR,LF,"CONFIRM? (Y/N)--", ETX
CMD_C_DONEMSG	DB	CR,LF,"MEMORY COPY COMPLETE",CR,LF,ETX

		

;********************************************************************
;*********************  DUMP MEMORY BRANCH  *************************
;  NAME: CMD_D
;  FUNCTION: DISPLAYS BLOCK OF MEMORY
;  INPUTS: NONE
;  OUTPUTS: NONE
;  USER IO: REQUESTS STARTING AND ENDING ADDRESSES, DISPLAYS MEM VALUES BETWEEN
;  DESTROYS: A. F/F'S,BC,DE,HL
;  CALLS: HO, GETHEXWORD, SENDSTRING, SEND_HL, NEWLINE, SEND_DE, CO
;  DESCRIPTION:THE USER IS ASKED FOR THE STARTING AND ENDING MEMORY ADDRESSES
;     THE PROGRAM THEN DISPLAYS THE VALUES OF MEMORY
;;********************************************************************
CMD_D:
	LXI	H,CMD_D_SMSG	;MSG TO USER FOR START ADDRESS
	CALL	SENDSTRING
	CALL	GETHEXWORD	;PUT STARTING ADDRESS INTO HL
	XCHG			;MOVE STARTING ADDRESS INTO DE
	LXI	H,CMD_D_EMSG	;ASK FOR ENDING ADDRESS
	CALL	SENDSTRING
	CALL	GETHEXWORD	;PUT ENDING ADDRESS INTO HL
	XCHG			;SWAP SO START IN HL, END IN DE
	CALL	NEWLINE
 	CALL	SEND_HL		;REPEAT BACK TO USER OUR UNDERSTANDING OF ADDRESSES
 	MVI	A," "
 	CALL	CO
 	MVI	A,"T"
 	CALL	CO
 	MVI	A,"O"
 	CALL	CO
 	MVI	A," "
 	CALL	CO
 	CALL	SEND_DE
 	CALL	NEWLINE

CMD_D_LINE:
	PUSH	H		;SAVE HL FOR LATER
	CALL	SEND_HL		;SEND ADDRESS
	MVI	A,":"
	CALL	CO
	MVI	A," "
	CALL	CO
	MVI	B,0FH+1		;NUMBER OF LOCATIONS PER LINE

CMD_D_CHAR:
	MOV	A,M		;GET THE MEMORY VALUE
	CALL	HO		;DISPLAY M
	MOV	A,H		;SEE IF WE ARE DONE:
	CMP	D		;SEE HIGH BYTE IS THE SAME
	JNZ	CMD_D_NEXTMEM	;IF NOT EQUAL, CONTINUE LOOP
	MOV	A,L		
	CMP	E		;IF HIGH BYTE SAME, CHECK LOW BYTE
	JZ	CMD_D_HEX_DONE	;DISPLAYED ENDING ADDRESS, WE ARE DONE


CMD_D_NEXTMEM:
	MVI	A,SPACE		;PUT A SPACE BETWEEN VALUES
	CALL	CO
	INX	H		;NEXT LOCATION
	DCR	B		;ONE LESS FOR THIS LINE
	JNZ	CMD_D_CHAR	;MORE TO DO ON THIS LINE

CMD_D_HEX_DONE:
				;LINE IS DONE. LETS REDISPLAY AS ASCII
	POP	B		;WAS PUSHED AS H, GET BACK AS THE STARTING ADDRESS FOR LINE WE JUST DID
	PUSH	H		;SAVE OUR PLACE FOR NEXT LOCATION TO OUTPUT	
	MOV	H,B		;M IS NOW BACK AT THE BEGINNING OF THE LINE
	MOV	L,C

	MVI	B,0FH+1		;NUMBER OF LOCATIONS PER LINE
	MVI	A,SPACE
	CALL	CO

CMD_D_ASCII:
	MOV	A,M		;GET CHARACTER AGAIN
	CPI	SPACE		;LESS THAN SPACE
	JC	CMD_D_SWAP4DOT	;NONDISPLAYABLE CHARACTER.  TO SMALL
	CPI	"~"		
	JC	CMD_D_ASCII1	;DISPLAYABLE SO CONTINUE
CMD_D_SWAP4DOT:
	MVI	A,"."

CMD_D_ASCII1:
	CALL	CO

CMD_D_NEXTASCII:
	MOV	A,H		;SEE IF WE ARE DONE:
	CMP	D		;SEE HIGH BYTE IS THE SAME
	JNZ	CMD_D_ASCIICONT	;IF NOT EQUAL, CONTINUE LOOP
	MOV	A,L
	CMP	E		;IF HIGH BYTE SAME, CHECK LOW BYTE
	JZ	CMD_D_DONE	;DISPLAYED ENDING ADDRESS, WE ARE DONE

CMD_D_ASCIICONT:
	DCR	B
	INX	H		;POINT TO NEXT
	JNZ	CMD_D_ASCII			
				;WE ARE DONE WITH ASCII
	POP	H		;RESTORE LAST ADDRESS OUTPUT
	CALL	NEWLINE		
	JMP	CMD_D_LINE	;DO NEXT LINE

CMD_D_DONE:			;DONE DISPLAYING MEMORY
	POP	H		;CLEAN UP STACK THE STACK
	CALL	NEWLINE
	JMP	CMD_PROMPT	;DONE HERE, RETURN TO COMMAND PROCESSOR	

CMD_D_USE:	DB	"D -- (D)UMP MEMORY BETWEEN START AND END ADDRESSES", CR, LF, ETX
CMD_D_SMSG	DB	"HEX STARTING ADDRESS? (XXXX)",CR,LF,ETX
CMD_D_EMSG	DB	CR,LF,"HEX ENDING ADDRESS? (XXXX)",CR,LF,ETX




;********************************************************************
;************************  EDIT MEMORY BRANCH  ***************************
;  NAME: CMD_E
;  FUNCTION: EDITS USER SPECIFIED MEMORY VALUE
;  INPUTS: NONE
;  OUTPUTS: 
;  USER IO: REQUESTS STARTING ADDRESS, DISPLAYS CURRENT VALUE, ALLOWS USER TO EDIT
;  DESTROYS: A, F/F, BC, DE, HL
;  CALLS: SENDSTRING, GETHEXWORD, NEWLINE, HO, SEND_HL
;
;  DESCRIPTION:
;********************************************************************
CMD_E:
	LXI	H,CMD_E_REQADD	;REQUEST ADDRESS MESSAGE
	CALL	SENDSTRING
	CALL	GETHEXWORD	;PUT ADDRESS INTO HL
CMD_E_LOOP:
	CALL	NEWLINE		;FRESH LINE
	CALL	SEND_HL		;DISPLAY CURRENT MEMORY ADDRESS
	CALL	SENDSPACE	;SPACE
	MOV	A,M		;EXISTING VALUE INTO A
	CALL	HO		;SEND TO DISPLAY
	XCHG			;AFTER: DE=ADDRESS
	LXI	H,CMD_E_TO	;CHANGE BYTE TO ARROW
	CALL	SENDSTRING
	CALL	GETHEXBYTE	;GET USER'S REPLACEMENT BYTE. DE=ADDRESS, L=ANSWER
	XCHG			;AFTER: E=ANSWER, HL=ADDRESS
	JC	CMD_PROMPT	;USER ENTERED ESCAPE, SO ABORT--- WE ARE TOTALLY DONE
	JZ	CMD_E_SKIP	;USER SHORTED ANSWER, SO SKIP AND MOVE ON

CMD_E_NEXT:
	MOV	M,E		;CHANGE MEMORY CONTENTS WITH USER VALUE
CMD_E_SKIP:
	INX	H		;NEXT ADDRESS
	JMP	CMD_E_LOOP	;DO NEXT

CMD_E_USE:	DB	"E -- (E)DIT SEQUENTIAL MEMORY CONTENTS. (CR TO SKIP, ESC TO QUIT)", CR, LF, ETX
CMD_E_REQADD:	DB	"HEX ADDRESS? (XXXX)-- ", ETX
CMD_E_TO:	DB	" -> ", ETX

;********************************************************************
;*********************  FILL MEMORY BRANCH  *************************
;  NAME: FILL MEMORY
;  FUNCTION: FILLS A BLOCK OF MEMORY WITH SPECIFIED VALUE
;  INPUTS: NONE
;  OUTPUTS: NONE
;  USER IO: REQUESTS STARTING AND ENDING ADDRESSES, FILLS MEM VALUES BETWEEN
;  DESTROYS: PSW,BC,DE,HL
;  CALLS: HO
;  DESCRIPTION:THE USER IS ASKED FOR THE STARTING AND ENDING MEMORY ADDRESSES
;     THE PROGRAM THEN DISPLAYS THE VALUES OF MEMORY
;;********************************************************************
CMD_F:
MEMORY_FILL:
	LXI	H,MSG_FILLMEMS	;MSG TO USER FOR START ADDRESS
	CALL	SENDSTRING
	CALL	GETHEXWORD	;PUT STARTING ADDRESS INTO HL
	XCHG			;MOVE STARTING ADDRESS INTO DE
	LXI	H,MSG_FILLMEME	;ASK FOR ENDING ADDRESS
	CALL	SENDSTRING
	CALL	GETHEXWORD	;PUT ENDING ADDRESS INTO HL
	XCHG			;SWAP SO START IN HL, END IN DE
	CALL	NEWLINE
 	CALL	SEND_HL		;REPEAT BACK TO USER OUR UNDERSTANDING OF ADDRESSES
 	MVI	A," "
 	CALL	CO
 	MVI	A,"T"
 	CALL	CO
 	MVI	A,"O"
 	CALL	CO
 	MVI	A," "
 	CALL	CO
 	CALL	SEND_DE
 	CALL	NEWLINE
	PUSH	H		;STORE HL FOR A MOMENT
	LXI	H,MSG_FILLVALUE	;INSTRUCTIONS FOR FILL BYTE
	CALL	SENDSTRING
	CALL	GETHEXBYTE	;GET FILL BYTE
	MOV	B,L		;PUT VALUE INTO B
	POP	H		;RESTORE HL PAIR
	RZ			;USER CHOSE QUIT, SO QUIT

	DCX	H		;BACKUP POINTER SO INX CAN BE FIRST LOOP INSTRUCTION
	PUSH	H
	LXI	H,MSG_FILLSTATUS	;GIVE FEEDBACK TO USER
	CALL	SENDSTRING
	CALL	NEWLINE	
	POP	H		
FILLMEMBYTE:
	INX	H		;ADVANCE MEMORY LOCATION
	CALL	SEND_HL
	CALL	SENDCR
	MOV	M,B		;WRITE THE BYTE
	MOV	A,H		;SEE IF WE ARE DONE:
	CMP	D		;SEE HIGH BYTE IS THE SAME
	JNZ	FILLMEMBYTE	;IF NOT EQUAL, CONTINUE LOOP
	MOV	A,L
	CMP	E		;IF HIGH BYTE WAS THE SAME, NOW CHECK LOW BYTE
	JNZ	FILLMEMBYTE	;LOW BYTE DOES NOT MATCH, NOT DONE

	CALL	NEWLINE
	LXI	H,MSG_FILLDONE	;GIVE FEEDBACK TO USER
	CALL	SENDSTRING	

	JMP	CMD_PROMPT	;DONE HERE, RETURN TO COMMAND PROCESSOR	

MSG_FILLMEMS	DB	"HEX STARTING ADDRESS (XXXX)",CR,LF,ETX
MSG_FILLMEME	DB	CR,LF,"HEX ENDING ADDRESS IN HEX (XXXX)",CR,LF,ETX
MSG_FILLVALUE	DB	"ENTER TWO DIGIT HEX VALUE TO WRITE INTO MEMORY (XX)",CR,LF
MSG_FILLVALUE1	DB	"OR ENTER BLANK LINE TO CANCEL",CR,LF,ETX
MSG_FILLSTATUS	DB	CR,LF,"FILLING MEMORY .....",ETX
MSG_FILLDONE	DB	"DONE.",CR,LF,LF,ETX
CMD_F_USE:	DB	"F -- (F)ILL RAM WITH SPECIFIED BYTE", CR, LF, ETX

;********************************************************************
;************** GO  *******************
;********************************************************************
;  NAME: CMD_G
;  FUNCTION: CHANGES PC TO USER SPECIFIED ADDRESS FOR "GO" COMMAND
;  INPUTS: NONE
;  OUTPUTS: NONE
;  USER IO: USER ENTERS GOTO ADDRESS
;  DESTROYS: A, F/F'S, DE, HL
;  CALLS: SENDSTRING, CI
;  DESCRIPTION: REQUESTS ADDRESS AND CONFIRMATION FROM USER. IF CONFIRMED
;	MOVES PROGRAM COUNTER TO THAT ADDRESS.  UP TO THE USER HOW WE GET
;	BACK TO THE COMMAND PROMPT.
;********************************************************************
CMD_G:	
	LXI	H,CMD_G_SMSG	;MSG TO USER FOR GOTO ADDRESS
	CALL	SENDSTRING
	CALL	GETHEXWORD	;PUT GOTO ADDRESS INTO HL
	XCHG			;MOVE GOTO ADDRESS INTO DE

	LXI	H,CMD_G_CONFIRM	;CONFIRM
	CALL	SENDSTRING
	CALL	SEND_DE		;DISPLAY USER ENTERED ADDRESS
	LXI	H,CMD_G_YN	;MSG TO USER FOR GOTO ADDRESS
	CALL	SENDSTRING
	CALL	CI		;GET USER RESPONSE
	CALL	CO
	CPI	"Y"		;COMPARE TO "Y"
	JNZ	CMD_PROMPT	;NOT A Y, SO RETURN TO COMMAND PROCESSOR
	XCHG			;OTHERWISE, PUT GOTO ADDRESS INTO HL
	CALL	NEWLINE		;FRESH LINE
	PCHL			;ADIOS, JUST HOPE THE USER KNOWS WHAT THEY ARE DOING


CMD_G_USE:	DB	"G -- (G)O TO ADDRESS AND RUN", CR, LF, ETX
CMD_G_SMSG:	DB	"GO TO ADDRESS (HEX)? (XXXX)--", ETX
CMD_G_CONFIRM:	DB	CR,LF,"CHANGE PROGRAM COUNTER TO ", ETX	
CMD_G_YN:	DB	" (Y/N)-- ", ETX	

;********************************************************************
;************** HELP WITH COMMANDS AND COMMAND USE  *******************
;********************************************************************
;  NAME: CMD_H
;  FUNCTION: DISPLAYS THE HELP COMMAND LIST
;  INPUTS: NONE
;  OUTPUTS: NONE
;  USER IO: USER ENTERS ? OR H
;  DESTROYS: A, F/F'S, BC, HL
;  CALLS: SENDSTRING
;  DESCRIPTION: DISPLAYS COMMANDS AND USAGE
;********************************************************************
CMD_H:				
	LXI	H,CMD_LIST	;SEND COMMAND LIST
	CALL	SENDSTRING
	LXI	H,CMD_USE_TBL	;NOW LOAD COMMAND USE TABLE
	MVI	B,CMD_TBL_LEN	;NUMBER OF COMMANDS
CMD_H_LOOP:
	MOV	E,M		;PUT LOW BYTE OF STRING ADDRESS IN E
	INX	H		;POINT TO MSB
	MOV	D,M		;PUT MSB OF STRING ADDRESS IN D
	XCHG			;DE<->HL
	CALL	SENDSTRING	;SEND TEXT POINTED BY HL
	XCHG			;DE<->HL BACK
	INX	H		;NEXT ADDRESS IS FUNCTION LSB ADDRESS
	INX	H		;NEXT ADDRESS IS FUNCTION MSB ADDRESS
	INX	H		;NEXT ADDRESS IS THE NEXT "USE" ADDRESS
	DCR	B		;ONE LESS TO DO
	JNZ	CMD_H_LOOP	;IF NOT DONE, DO MORE
	JMP	CMD_PROMPT	;DONE HERE, RETURN TO COMMAND PROCESSOR	

CMD_LIST:	DB	"STD-85 CONFIDENCE TEST:", CR, LF, ETX
CMD_?_USE:	DB	"? -- HELP", CR, LF, ETX
CMD_H_USE:	DB	"H -- (H)ELP", CR, LF, ETX
CMD__USE:	DB	ETX	;UNUSED COMMAND, SKIP	


;********************************************************************
;**********  INPUT FROM PORT AND DISPLAY TO USER  ***************
;********************************************************************
;  NAME: CMD_I
;  FUNCTION: READ 8155 PORTS A, B, C AND DISPLAY TO USER
;  INPUTS: NONE
;  OUTPUTS: NONE
;  USER IO: DISPLAYS VALUES TO USER IN HEX AND BINARY
;  DESTROYS: A, F/F'S, H
;  CALLS: SENDSTRING, HO, SENDSPACE, SENDTAB, SENDCR
;  DESCRIPTION: READS I0, I1, AND I2.  DISPLAYS ON SINGLE LINE UNTIL
;     A CHARACTER IS ENTERED ON TERMINAL. CHARACTER ENTERED GOES TO BB
;********************************************************************
CMD_I:				
	MVI	A,i8155_III	;MASK TO SET A,B,C TO IN, IN, IN
	OUT	i8155_CS	;SEND TO 8155 COMMAND STATUS
	MVI	A,0FFH		;RESET STOP FLAG BUFFER WHICH IS USED TO 
	STA	STOP_FLAG	;  DETECT IF THERE WAS A CHARACTER INPUT
	LXI	H,CMD_I_INST	;INSTRUCTIONS TO USER
	CALL	SENDSTRING
	CALL	CMD_I_LOOP	;GET AND DISPLAY INPUT PORT VALUES
	CALL	SENDCR		;CURSER BACK TO BEGINNING OF LINE
	IN	i8155_A		;GET 8155 PORT A
	RRC			;COPY LSBIT INTO CARRY 
	RNC 			; IF LOW, USER ENTERED A CHARACTER
	JMP	CMD_I_LOOP	; OTHERWISE, LOOP AGAIN



CMD_I_LOOP:			;LOOP IS USED ELSEWHERE
	LXI	H,CMD_I_I0	;DISPLAY I0 LABEL
	CALL	SENDSTRING	;
	IN	i8155_A		;GET 8155 PORT A
	CALL	HO		;DISPLAY AS HEX
	CALL	SENDSPACE	;SPACE
	CALL	BOB		;SEND OUT AS BINARY
	CALL	SENDTAB		;TAB TO NEXT
	LXI	H,CMD_I_I1	;DISPLAY I1 LABEL
	CALL	SENDSTRING	;
	IN	i8155_B		;GET 8155 PORT B
	CALL	HO		;DISPLAY AS HEX
	CALL	SENDSPACE	;SPACE
	CALL	BOB		;SEND OUT AS BINARY
	CALL	SENDTAB		;TAB TO NEXT
	LXI	H,CMD_I_I2	;DISPLAY I2 LABEL
	CALL	SENDSTRING	;
	IN	i8155_C		;GET 8155 PORT C
	CALL	HO		;DISPLAY AS HEX
	CALL	SENDSPACE	;SPACE
	CALL	BOB		;SEND OUT AS BINARY
	CALL	SENDCR		;SEND CARRIAGE RETURN
	LDA	STOP_FLAG	;GET STOP FLAG WHICH WAS SET BY CI SUBROUTINE
	RLC			;COPY MSBIT INTO CARRY 
	RNC 			; IF LOW, USER ENTERED A CHARACTER
	JMP	CMD_I_LOOP	; OTHERWISE, LOOP AGAIN




CMD_I_I0:	DB	"I0: 0x", ETX
CMD_I_I1:	DB	"   I1: 0x", ETX
CMD_I_I2:	DB	"   I2: 0x", ETX
CMD_I_USE:	DB	"I -- (I)NPUT I0, I1, I2, AND DISPLAY VALUES", CR, LF, ETX
CMD_I_INST:	DB	CR,LF, "VALUES OF 8155 PORTS A, B, AND C ARE:",CR,LF
CMD_I_INST2:	DB	"PRESS ANY KEY...",CR,LF,LF,ETX


;********************************************************************
;*************  LIST AND READ FROM MEMORY LOCATIONS  ***************
;  NAME: CMD_LIST
;  FUNCTION: SEQUENCES THROUGH LIST OF MEMORY LOCATIONS TO READ
;  INPUTS: NONE
;  OUTPUTS: NONE
;  USER IO: REQUESTS LIST OF ADDRESSES, END LIST INPUT WITH A CARRIAGE RETURN
;  DESTROYS: A,PSW,BC,DE,HL
;  CALLS: GET_LIST,
;  DESCRIPTION:AIDS IN MEMORY DIAGNOSTICS.  USER INPUTS LIST OF ADDRESS LOCATIONS
;      ENDING WITH A BLANK LINE.  PROGRAM THEN SEQUENTLY READS THESE ADDRESSES
;      TO ALLOW TESTING OF THE ADDRESS LINES AND CHIP SELECTS
;      NOTCHES INTE PIN FOR LOGIC PROBE MARKER RIGHT BEFORE READ OF FIRST ADDRESS IN LIST.
;********************************************************************

CMD_L:
MEMORY_READ:
	MVI	A,0FFH		;RESET STOP FLAG BUFFER WHICH IS USED TO 
	STA	STOP_FLAG	;  DETECT IF THERE WAS A CHARACTER INPUT
	CALL	GET_MLIST	;GET LIST FROM USER, LIST COUNT RETURNED IN REG B
	MOV	A,B		;COPY NUMBER OF ADDRESSES TO REG A
	ORA	A		;CHECK IF LIST IS ACTUALLY EMPTY
	RZ			;IF LIST LENGTH IS ZERO, QUIT
	LXI	H,GETMLISTINST2	;RUNNING, SEND EXIT INSTRUCTIONS TO USER
	CALL	SENDSTRING

MEMREADRESET:			;NOW DO A READ/WRITE OF EACH ADDRESS IN LIST
	LXI	H,STOP_FLAG	;HL WILL BE POINTER TO CURRENT ENTRY IN ADDRESS LIST
	EI			;SEND INTE STROBE FOR LOGIC PROBE TRIGGER
	DI			;
	MOV	C,B		;RELOAD NUMBER OF ADDRESSES IN REGISTER C

MEMREAD:	
	MOV	D,M		;GET ADDRESS FROM LIST AND PUT INTO DE PAIR, BIG ENDIAN
	INX	H
	MOV	E,M
	INX	H
	CALL	SEND_DE		;DISPLAY MEMORY LOCATION
	MVI	A,":"
	CALL	CO
	LDAX	D		;READ MEMORY LOCATION
	CALL	HO		;SEND MEMORY LOCATION TO DISPLAY
	CALL	SENDSPACE	;SEND A SPACE
	DCR	C		;ONE DONE
	JNZ	MEMREAD		;MORE TO DO
	CALL	SENDCR		;SEND CARRIAGE RETURN
	LDA	STOP_FLAG	;GET STOP FLAG WHICH WAS SET BY CI SUBROUTINE
	RLC			;COPY MSBIT INTO CARRY 
	RNC 			; IF LOW, USER ENTERED A CHARACTER
	JMP	MEMREADRESET	;RESET LIST POINTER AND REDO

CMD_L_USE:	DB	"L -- (L)IST AND TOGGLE READ FROM MEMORY LOCATIONS", CR, LF, ETX



;********************************************************************
;************************  MAP RAM BRANCH  ***************************
;  NAME: MAP_RAM
;  FUNCTION: MAPS RAM
;  INPUTS: NONE
;  OUTPUTS: NONE
;  USER IO: DISPLAYS ANY BLOCKS OF RAM IN MEMORY RANGE
;  DESTROYS: A, B, PSW,HL
;  CALLS: HO, GETHEXWORD
;  DESCRIPTION:SEARCHES THE ENTIRE MEMORY RANGE TO IDENTIFY RAM LOCATIONS
;     DISPLAYS RESULTING RAM BLOCKS TO USER
;********************************************************************
CMD_M:
	LXI	H,MAP_RAM_INST	;MSG TO USER
	CALL	SENDSTRING
	LXI	H,0000H		;ZERO MEMORY POINTER
	
MAP_FINDSTART:
	INX	H		;A CHEAT, BUT WE KNOW 0X0000 ISN'T RAM SO SKIP
	CALL	SEND_HL		;DISPLAY ADDRESS
	MVI	A,CR		;BACK OVER IT
	CALL	CO
	MOV	A,H		;SEE IF WE ARE DONE
	ORA	L		;
	RZ			;DONE. WE CAN JUST RETURN TO COMMAND PROCESSOR
	MOV	M,A		;LOAD SOME VALUE INTO MEMORY
	CMP	M		;SEE IF THE VALUE STUCK
	JNZ	MAP_FINDSTART	;DIDN'T REMEMBER VALUE, SO NOT RAM
	CMA			;HMMMM.  LOCATION MATCHED. DOUBLE CHECK. FLIP BITS
	MOV	M,A		;TRY AGAIN
	CMP	M		;AND SEE IF IT REMEMBERS NEW VALUE
	JNZ	MAP_FINDSTART	;DIDN'T STICK, NOT FUNCTIONAL RAM
	CALL	SEND_HL		;SEEMS TO BE A WORKING RAM ADDRESS, OUTPUT TO USER AS BLOCK START
	MVI	A,"-"		;IT IS ALL ABOUT THE DASH BETWEEN THE DATES ISN'T IT.
	CALL	CO
	
MAP_FINDEND:
	INX	H		;NOW FIND END OF RAM
	CALL	SEND_HL		;DISPLAY ADDRESS
	MVI	A,BS		;BACK OVER IT
	CALL	CO
	CALL	CO
	CALL	CO
	CALL	CO
	MOV	M,A		;TEST LOCATION
	CMP	M
	JNZ	MAP_FOUNDEND	;NOT RAM, MARK AS END
	CMA			;DOUBLE TEST
	MOV	M,A
	CMP	M
	JNZ	MAP_FOUNDEND	;FAILED SECOND TEST, NOT RAM
	MOV	A,H		;SEE IF WE ARE DONE
	ORA	L		;
	JNZ	MAP_FINDEND	;NOT AT END OF PHYSICAL MEMORY ADDRESSES, KEEP LOOKING
	DCX	H		;CURRENT POINTER NOT RAM, SO POINT TO ONE ADDRESS EARLIER
	CALL	SEND_HL		;DISPLAY AS LAST ADDRESS IN THIS BLOCK
	CALL	NEWLINE		;
	RET			;DONE WITH MAP SO RETURN

MAP_FOUNDEND:			;OUTPUT AS ENDING BLOCK
	DCX	H		;CURRENT POINTER NOT RAM, SO POINT TO ONE ADDRESS EARLIER
	CALL	SEND_HL		;DISPLAY AS LAST ADDRESS IN THIS BLOCK
	CALL	NEWLINE		;
	INX	H		;POINT BACK TO WHERE WE LEFT OFF
	JMP	MAP_FINDSTART	;SEARCH FOR START OF NEXT BLOCK
	
MAP_RAM_INST	DB	"RAM ADDRESS BLOCK MAP:",CR,LF,ETX
CMD_M_USE:	DB	"M -- (M)AP RAM", CR, LF, ETX

;********************************************************************
;***************** OUTPUT USER VALUE TO SELECTED PORT  *********************
;********************************************************************
;  NAME: CMD_O
;  FUNCTION: SENDS USER ENTERED SETPOINT TO BITS 0-7
;  INPUTS: NONE
;  OUTPUTS: NONE
;  USER IO: REQUESTS A TWO CHARACTER HEX SETPOINT FROM THE USER
;  DESTROYS: A, F/F'S, HL
;  CALLS: SENDSTRING, GETHEXBYTE, SENDCR
;  DESCRIPTION: REQUESTS VALUE FROM USER, OUTPUTS TO BITS 0-7
;     CONTINUES UNTIL CARRIAGE RETURN IS ENTERED
;********************************************************************
CMD_O:	
	MVI	A,i8155_OOO	;MASK TO SET A,B,C TO OUT,OUT,OUT
	OUT	i8155_CS	;SEND TO 8155 COMMAND STATUS

	LXI	H,CMD_O_INSTP	;PROMPT USER FOR PORT NUMBER
	CALL	SENDSTRING
	CALL	GETHEXBYTE	;GET HEX BYTE FROM USER
	RZ			;IF RETURNED WITH ZERO SET, LESS THAN 2 CHARACTERS SO EXIT
	MOV	A,L		;RETURNED VALUE IN L, MOVE TO ACC.
	LXI	H,RUNTIME	;POINT TO RUNTIME PROGRAM BUFFER
	MVI	M,0D3H		;LOAD OUT INSTRUCTION
	INX	H		;INCREMENT M TO NEXT LOCATION
	MOV	M,A		;LOAD PORT NUMBER
	INX	H		;NEXT M
	MVI	M,0C9H		;LOAD RETURN INSTRUCTION
	LXI	H,CMD_O_PRMPTP	;TELL USER WHICH PORT
	CALL	SENDSTRING
	CALL	HO		;SEND OUTPUT PORT NUMBER
	CALL	NEWLINE	
	CPI	OBP		;COMPARE OUTPUT PORT WITH ON BOARD PORT
	JNZ	CMD_O_LOOP	;IF NOT OBP, JUST CONTINUE
	LXI	H,CMD_O_WARNING	;  OTHERWISE, WARN USER ABOUT LSBIT
	CALL	SENDSTRING
	CALL	NEWLINE		

CMD_O_LOOP:
	LXI	H,RUNTIME	;POINT TO RUNTIME PROGRAM BUFFER
	MVI	M,0D3H		;LOAD OUT INSTRUCTION
	LXI	H,CMD_O_INSTV	;ASK USER WHAT VALUE
	CALL	SENDSTRING
	LXI	H,CMD_O_PRMPT
	CALL	SENDSTRING
	CALL	GETHEXBYTE	;GET HEX PATTERN BYTE FROM USER
	RZ			;IF RETURNED WITH ZERO SET, LESS THAN 2 CHARACTERS SO EXIT
	MOV	A,L		;RETURNED VALUE IN L, MOVE TO ACC.
	CALL	RUNTIME		;OTHERWISE, SEND OUTPUT PATTERN TO PORT
	LXI	H,BUFFER2	;DIAGNOSTIC--SAVE OUTPUT PATTERN TO BUFFER FOR DUMP INSPECTION
	MOV	M,A
	CALL	SENDSPACE	;NOW SEND SPACE TO TERMINAL
 	CALL	BOB		;SEND OUTPUT VALUE TO TERMINAL AS BINARY
	CALL	NEWLINE		;NEW LINE
	LXI	H,CMD_O_IPRMPT
	CALL	SENDSTRING

	LXI	H,RUNTIME	;POINT TO RUNTIME PROGRAM BUFFER
	MVI	M,0DBH		;LOAD IN INSTRUCTION
	CALL	RUNTIME		;GET INPUT FROM PORT, LEAVE IN ACCUMULATOR
	CALL	HO		;DISPLAY AS HEX
	CALL	SENDSPACE
	CALL	BOB		;DISPLAY AS BINARY

	CALL	NEWLINE		;NEW LINE
	JMP	CMD_O_LOOP	;LOOP

CMD_O_USE:	DB	"O -- (O)UTPUT PATTERN BYTE TO USER SELECTED PORT", CR, LF, ETX
CMD_O_INSTP:	DB	CR,LF, "HEX PORT NUMBER (00-FF) OR A CARRIAGE RETURN TO EXIT",CR,LF,ETX
CMD_O_INSTV:	DB	CR,LF, "HEX OUTPUT PATTERN (00-FF) OR A CARRIAGE RETURN TO EXIT",CR,LF,ETX
CMD_O_WARNING:	DB	CR,LF, "WARNING--LEAST SIGNIFICANT BIT OF THIS PORT SELECTS MEMORY MAP. 0=DEFAULT, 1=ALTERNATE",CR,LF,ETX
CMD_O_PRMPTP:	DB	CR,LF,"OUT TO PORT ",ETX
CMD_O_PRMPT:	DB	CR,LF,"OUT = 0x",ETX
CMD_O_IPRMPT:	DB	CR,LF,"IN = 0x",ETX



;********************************************************************
;************************  RAM CHECK BRANCH  ***************************
;  NAME: CMD_R
;  FUNCTION: PERFORMS CHECK OF SYSTEM RAM
;  INPUTS: NONE
;  OUTPUTS: 
;  USER IO: PROVIDES STATUS TO USER VIA SERIAL PORT. ENDS WITH 
;    BEGINNING AND ENDING LOCATION OF RAM.
;    DISPLAYS TEST NUMBER TO USER VIA SERIAL PORT
;  DESTROYS: A, BC, DE, HL, SP
;  CALLS: NEWLINE, SENDSTRING, SEND_DE, SEND_HL, CO
;
;  DESCRIPTION:
;    RAMCHK IDENTIFIES THE BOTTOM OF RAM TO USER.
;    IT THEN STARTS AT THE BOTTOM OF RAM AND PUTS PATTERN INTO MEMORY LOCATION
;    TESTS FOR MATCH, THEN FLIPS PATTERN AND RETESTS.  IF LOCATION PASSES IT
;    MOVES UP ONE MEMORY LOCATION
;    RAM TEST CONTINUES UNTIL INTERRUPTED WITH ANOTHER KEYSTROKE BY USER
;     ####### WARNING #####
;    RAMCHK PRETTY MUCH DESTORYS EVERYTHING.
;    FOR THIS REASON THERE ARE PERIODS
;    WHERE THERE SHOULD BE NO CALLS TO SUBROUTINES BECAUSE THE STACK MAY
;    BE DESTROYED.  
;********************************************************************


CMD_R:
	LXI	D,0000H		;CLEAR DE PAIR

CMD_R0:
	INX	D		;INCREMENT TEST COUNT NUMBER

	LXI	SP,STACK_8155
	LXI	H,BO_6264
	SHLD	BUFFER2
	CALL	R_TEST		;DO THE TEST UNTIL FIRST FAIL OR DONE



CMD_R1:
	LXI	SP,STACK_6264
	LXI	H,BO_8155
	SHLD	BUFFER2
	CALL	R_TEST		;DO THE TEST UNTIL FIRST FAIL


	JMP	CMD_R0		;THEN START OVER WITH NEW TEST

R_TEST:	
	CALL	NEWLINE
	LXI	H,MSG_RAMTEST	;RAM TEST SPLASH LINE
	CALL	SENDSTRING
	CALL	NEWLINE
	LXI	H,MSG_TESTCT	;'TEST COUNTER' STRING
	CALL	SENDSTRING	;
	CALL	SEND_DE		;DISPLAY TEST COUNT
	CALL	NEWLINE		;
	LXI	H,MSG_BOR	;LOAD POINTER TO 'BOTTOM OF RAM' STRING
	CALL	SENDSTRING	;
	LHLD	BUFFER2		;LOAD HL WITH ADDRESS
	CALL	SEND_HL		;DISPLAY STARTING ADDRESS
	CALL	NEWLINE		;
	LXI	H,MSG_TOR	; 'TOP OF RAM' STRING
	CALL	SENDSTRING	;

				;NOW ACTUALLY START TEST
	LHLD	BUFFER2		;RELOAD HL WITH BOTTOM OF RAM
	CALL	SEND_HL		;DISPLAY ADDRESS
	
MEMLUP:				;TEST AN INDIVIDUAL MEMORY LOCATION
	MVI	A,0AAH		;STARTING PATTERN
	MOV	M,A		;PATTERN INTO MEMORY
	CMP	M		;TEST
	JNZ	BADMEM		;END IF NO MATCH
	CMA			;FLIP PATTERN
	MOV	M,A		;NEW PATTERN INTO MEMORY
	CMP	M		;TEST
	JNZ	BADMEM		;IF NOT MATCH,THEN END
;NOW WALK PATTERN
	MVI	A,10000000B	;STARTING PATTERN
	MOV	M,A		;PATTERN INTO MEMORY
	CMP	M		;TEST
	JNZ	BADMEM		;END IF NO MATCH
	RRC			;ROTATE
	MOV	M,A		;NEW PATTERN INTO MEMORY
	CMP	M		;TEST
	JNZ	BADMEM		;IF NOT MATCH,THEN END
	RRC			;ROTATE
	MOV	M,A		;NEW PATTERN INTO MEMORY
	CMP	M		;TEST
	JNZ	BADMEM		;IF NOT MATCH,THEN END
	RRC			;ROTATE
	MOV	M,A		;NEW PATTERN INTO MEMORY
	CMP	M		;TEST
	JNZ	BADMEM		;IF NOT MATCH,THEN END
	RRC			;ROTATE
	MOV	M,A		;NEW PATTERN INTO MEMORY
	CMP	M		;TEST
	JNZ	BADMEM		;IF NOT MATCH,THEN END
	RRC			;ROTATE
	MOV	M,A		;NEW PATTERN INTO MEMORY
	CMP	M		;TEST
	JNZ	BADMEM		;IF NOT MATCH,THEN END
	RRC			;ROTATE
	MOV	M,A		;NEW PATTERN INTO MEMORY
	CMP	M		;TEST
	JNZ	BADMEM		;IF NOT MATCH,THEN END
	RRC			;ROTATE
	MOV	M,A		;NEW PATTERN INTO MEMORY
	CMP	M		;TEST
	JNZ	BADMEM		;IF NOT MATCH,THEN END
	RRC			;ROTATE
	MOV	M,A		;NEW PATTERN INTO MEMORY
	CMP	M		;TEST
	JNZ	BADMEM		;IF NOT MATCH,THEN END

;IF WE ARRIVED HERE, THIS LOCATION HAS TESTED OK, DISPLAY ADDRESS
	MVI	A,0FFH		;RESET STOP FLAG BUFFER WHICH IS USED TO 
	STA	STOP_FLAG	;  DETECT IF THERE WAS A CHARACTER INPUT

	MVI	A,BS		;BACKSPACE 4X OVER LAST ADDRESS
	CALL	CO
	CALL	CO
	CALL	CO
	CALL	CO	
	CALL	SEND_HL		;DISPLAY NEW ADDRESS


CI?:				;HOW WE END DEPENDS ON WHERE WE ARE. 6264 WOULD ROLL INTO 8155
	LDA	STOP_FLAG	;GET STOP FLAG WHICH WAS SET BY CI SUBROUTINE
	RLC			;COPY MSBIT INTO CARRY 
	JNC 	0000H		; IF LOW, USER ENTERED A CHARACTER

	MOV	A,H		;GET HIGH BYTE OF TESTING ADDRESS
	CPI	HIGH TO_6264	;ARE WE NEAR THE LAST OF THE 6264 LOCATIONS?
	JNZ	R_NEXT		;NO, EITHER NOT NEAR OR DOING 8155
	MOV	A,L		;YES, LOOK AT BOTTOM HALF OF ADDRESS
	CPI	0FFH		;IS IT THE LAST ADDRESS?
	JNZ	R_NEXT		;NO DO THE NEXT ONE
	JMP	BADMEM		;YES, DONE WITH 6264

R_NEXT:	INX	H		;MOVE UP ONE MEMORY LOCATION
	JMP	MEMLUP		; OTHERWISE, WE HAVE FINISHED ONE MEMORY LOCATION

BADMEM:				;JUMPS HERE WHEN MEMORY FAILED OR END OF 6264
	CALL	NEWLINE		;DISPLAY ALREADY SHOWING LAST GOOD ADDRESS
	RET			;RETURN TO SENDER


MSG_BOR		DB	"BOTTOM OF RAM: ",ETX
MSG_RAMTEST	DB	">>>  RAM TEST  <<<",ETX
MSG_TESTCT	DB	"TEST NUMBER:",ETX
MSG_TOR		DB	"   TOP OF RAM: ",ETX
CMD_R_USE:	DB	"R -- (R)AM TEST", CR, LF, ETX


;********************************************************************
;************************  STUCK BIT (RAM) TEST BRANCH  ***************************
;  NAME: STUCK BIT_TEST
;  FUNCTION: DISPLAYS BLOCK OF MEMORY
;  INPUTS: NONE
;  OUTPUTS: NONE
;  USER IO: REQUESTS STARTING AND ENDING ADDRESSES, TEST MEM BETWEEN
;  DESTROYS: PSW,BC,DE,HL
;  CALLS: HO
;  DESCRIPTION:THE USER IS ASKED FOR THE STARTING AND ENDING MEMORY ADDRESSES
;     THE PROGRAM THEN DISPLAYS THE VALUES OF MEMORY
;;********************************************************************
CMD_S
MEMORY_TEST:
	LXI	H,MSG_TESTMEMS	;MSG TO USER FOR START ADDRESS
	CALL	SENDSTRING
	CALL	GETHEXWORD	;PUT STARTING ADDRESS INTO HL
	XCHG			;MOVE STARTING ADDRESS INTO DE
	LXI	H,MSG_TESTMEME	;ASK FOR ENDING ADDRESS
	CALL	SENDSTRING
	CALL	GETHEXWORD	;PUT ENDING ADDRESS INTO HL
	XCHG			;SWAP SO START IN HL, END IN DE
	CALL	NEWLINE
 	CALL	SEND_HL		;REPEAT BACK TO USER OUR UNDERSTANDING OF ADDRESSES
 	MVI	A," "
 	CALL	CO
 	MVI	A,"T"
 	CALL	CO
 	MVI	A,"O"
 	CALL	CO
 	MVI	A," "
 	CALL	CO
 	CALL	SEND_DE
 	CALL	NEWLINE

MEMTESTLINE:
	CALL	SEND_HL		;SEND ADDRESS
	MVI	A,":"
	CALL	CO
	MVI	A," "
	CALL	CO
	DCX	H		;SO FIRST IN LOOP CAN BE INX

MEMTESTBYTE:
	INX	H		;NEXT MEMORY LOCATION
	MVI	A,0AAH		;STARTING PATTERN
	MOV	M,A		;PATTERN INTO MEMORY
	CMP	M		;TEST
	JNZ	MEMTESTBAD	;END IF NO MATCH
	CMA			;FLIP PATTERN
	MOV	M,A		;NEW PATTERN INTO MEMORY
	CMP	M		;TEST
	JNZ	MEMTESTBAD	;IF NOT MATCH,THEN MARK AS BAD
;NOW WALK PATTERN
	MVI	A,10000000B	;STARTING PATTERN
	MOV	M,A		;PATTERN INTO MEMORY
	CMP	M		;TEST
	JNZ	MEMTESTBAD	;END IF NO MATCH
	RRC			;ROTATE
	MOV	M,A		;NEW PATTERN INTO MEMORY
	CMP	M		;TEST
	JNZ	MEMTESTBAD	;IF NOT MATCH, MARK AS BAD
	RRC			;ROTATE
	MOV	M,A		;NEW PATTERN INTO MEMORY
	CMP	M		;TEST
	JNZ	MEMTESTBAD	;IF NOT MATCH, MARK AS BAD
	RRC			;ROTATE
	MOV	M,A		;NEW PATTERN INTO MEMORY
	CMP	M		;TEST
	JNZ	MEMTESTBAD	;IF NOT MATCH, MARK AS BAD
	RRC			;ROTATE
	MOV	M,A		;NEW PATTERN INTO MEMORY
	CMP	M		;TEST
	JNZ	MEMTESTBAD	;IF NOT MATCH, MARK AS BAD
	RRC			;ROTATE
	MOV	M,A		;NEW PATTERN INTO MEMORY
	CMP	M		;TEST
	JNZ	MEMTESTBAD	;IF NOT MATCH, MARK AS BAD
	RRC			;ROTATE
	MOV	M,A		;NEW PATTERN INTO MEMORY
	CMP	M		;TEST
	JNZ	MEMTESTBAD	;IF NOT MATCH, MARK AS BAD
	RRC			;ROTATE
	MOV	M,A		;NEW PATTERN INTO MEMORY
	CMP	M		;TEST
	JNZ	MEMTESTBAD	;IF NOT MATCH, MARK AS BAD
	RRC			;ROTATE
	MOV	M,A		;NEW PATTERN INTO MEMORY
	CMP	M		;TEST
	JNZ	MEMTESTBAD	;IF NOT MATCH, MARK AS BAD


	MVI	A,"P"		;FINISHED TESTING THIS BYTE
	JMP	MEMTESTRESULT	;DISPLAY RESULTS
MEMTESTBAD:
	MVI	A,"F"
MEMTESTRESULT:
	CALL	CO		;DISPLAY EITHER PASS OR FAIL SIGN
	MOV	A,H		;SEE IF WE ARE DONE:
	CMP	D		;SEE HIGH BYTE IS THE SAME
	JNZ	MEMTESTNEXT	;IF NOT EQUAL, CONTINUE LOOP
	MOV	A,L
	CMP	E		;IF HIGH BYTE SAME, CHECK LOW BYTE
	JZ	MEMTEST_DONE	;DISPLAYED ENDING ADDRESS, WE ARE DONE

MEMTESTNEXT:			;SEE IF WE ARE AT A BYTE BREAK
	MOV	A,L		;GET ADDRESS IN A
	ANI	00000111B	;CLEAR TOP
	CPI	00000111B	;SEE IF BOTTOM NIBBLE EVEN BYTE
	JNZ	MEMTESTBYTE	;NO, CONTINUE WITH NEXT LOCATION
	MVI	A,SPACE		;YES, PUT A SPACE BETWEEN BYTES
	CALL	CO		;
MEMTESTNEXT1:			;AT EVEN BYTE, ALSO EVEN WORD?
	MOV	A,L		;GET ADDRESS AGAIN
	ANI	00001111B	;CLEAR TOP
	CPI	00001111B	;EVEN 16?
	JNZ	MEMTESTBYTE	;NO, CONTINUE WITH NEXT LOCATION
	MVI	A,SPACE		;YES, PUT AN ADDITIONAL SPACE BETWEEN
	CALL	CO		;	
				;EVEN WORD, TIME FOR NEXT LINE?
	MOV	A,L		;ADDRESS INTO A
	ANI	00110000B	;IS TOP NIBBLE ONE BEFORE 0,4,8,OR C?
	CPI	00110000B	;TEST
	JNZ	MEMTESTBYTE	;NO, CONTINUE WITH NEXT LOCATION

	CALL	NEWLINE		;YES, NEW LINE
	INX	H		;NEXT MEMORY LOCATION
	JMP	MEMTESTLINE	;NEXT LINE


MEMTEST_DONE:			;DONE WITH MEMORY TEST
	CALL	NEWLINE
	JMP	CMD_PROMPT	;DONE HERE, RETURN TO COMMAND PROCESSOR	

CMD_S_USE:	DB	"S -- (S)TUCK (BAD) BIT FINDER. CHECK EACH BIT IN RAM BLOCK", CR, LF, ETX
MSG_TESTMEMS	DB	"ENTER STARTING MEMORY ADDRESS IN HEX (XXXX)",CR,LF,ETX
MSG_TESTMEME	DB	CR,LF,"ENTER ENDING MEMORY ADDRESS IN HEX (XXXX)",CR,LF,ETX


;********************************************************************
;******************  TTY TEST BRANCH  ********************
;  NAME: CMD_T
;  FUNCTION: SENDS PRINTABLE CHARACTERS TO TTY, THEN ECHOS INPUT BACK
;  INPUTS: NONE
;  OUTPUTS: NONE
;  USER IO: ASCII SET SENT TO TTY.  THEN USER ENTERS CHARACTER TO BE ECHOED
;  DESTROYS: HL
;  CALLS: SENDSTRING
;  DESCRIPTION:
;*********************************************************************

CMD_T:
	LXI	H,MSG_T_INST1	;POINT TO INSTRUCTION MESSAGE
	CALL	SENDSTRING	; AND SEND OUT

	MVI	A,SPACE		;START WITH THE SPACE
SENDASCII:
	CALL	CO		;SEND TO TTY
	INR	A		; NEXT CHARACTER
	CPI	"~"		;LAST PRINTABLE CHARACTER	
	JC	SENDASCII	;CONTINUE UNTIL DONE

	LXI	H,MSG_T_INST2	;POINT TO INSTRUCTION MESSAGE
	CALL	SENDSTRING	; AND SEND OUT
ECHOASCII:
	CALL	CI		;GET CHARACTER
	CPI	ESC		;IS IT AN ESCAPE?
	RZ			; YES, RETURN
	CALL	CO		;OTHERWISE ECHO
	JMP	ECHOASCII	;AND LOOP


MSG_T_INST1	DB	"PRINTABLE ASCII CHARACTER SET:", CR, LF, ETX
MSG_T_INST2	DB	CR,LF,LF,"CHARACTERS WILL BE ECHOED BACK TO TTY.  ENTER ESCAPE TO EXIT", CR, LF, ETX
CMD_T_USE:	DB	"T -- (T)TY TEST", CR, LF, ETX



;********************************************************************
;******************  VERSION INFORMATION BRANCH  ********************
;  NAME: CMD_V
;  FUNCTION: SENDS VERSION INFORMATION
;  INPUTS: NONE
;  OUTPUTS: NONE
;  USER IO: SENDS VERSION INFORMATION TO USER VIA SOD
;  DESTROYS: HL
;  CALLS: SENDSTRING
;  DESCRIPTION:DISPLAYS PROGRAM VERSION NUMBER VIA SERIAL PORT
;*********************************************************************

CMD_V:
	LXI	H,MSG_VERSION	;POINT TO 'VERSION' MESSAGE
	CALL	SENDSTRING	; AND SEND OUT
	RET

MSG_VERSION	DB	"STD-85 CONFIDENCE TEST VERSION ",V1,".",V2,".",V3, CR, LF
MSG_COPYRIGHT	DB	"COPYRIGHT 2022 CCAndrews", CR, LF
MSG_hello	DB	"Hello World   SBC-85.com", CR, LF, ETX
CMD_V_USE:	DB	"V -- (V)ERSION, COPYRIGHT, AND LICENSE INFORMATION", CR, LF, ETX





;********************************************************************
;*************  WRITE MEMORY FROM ADDRESS LIST BRANCH  ***************
;  NAME: MEMORY_WRITE
;  FUNCTION: SEQUENCES THROUGH LIST OF MEMORY LOCATIONS TO WRITE
;  INPUTS: NONE
;  OUTPUTS: NONE
;  USER IO: REQUESTS LIST OF ADDRESSES, END LIST INPUT WITH A CARRIAGE RETURN
;  DESTROYS: A,PSW,BC,DE,HL,RESETS SP
;  CALLS: GET_LIST, ROFFSET
;  DESCRIPTION:AIDS IN MEMORY DIAGNOSTICS.  USER INPUTS LIST OF ADDRESS LOCATIONS
;      ENDING WITH A BLANK LINE.  PROGRAM THEN SEQUENTLY WRITES TO THESE ADDRESSES
;      TO ALLOW TESTING OF THE ADDRESS LINES AND CHIP SELECTS
;      TOGGLES INTE PIN LOGIC PROBE MARKER RIGHT BEFORE READ OF FIRST ADDRESS IN LIST.
;********************************************************************

CMD_W:
MEMORY_WRITE:
	LXI	H,MEMWRTMSG1	;DISPLAY WARNING TO USER ABOUT OVERWRITING STACK
	CALL	SENDSTRING
	CALL	GET_MLIST	;GET LIST FROM USER, LIST COUNT RETURNED IN REG B
	LXI	H,MSG_FILLVALUE	;INSTRUCTIONS FOR FILL BYTE
	CALL	SENDSTRING
	CALL	GETHEXBYTE	;GET FILL BYTE
	CALL	NEWLINE
	MOV	A,L		;MOVE FILL VALUE
	STA	BUFFER1		;SAVE FILL VALUE TO RAM
	MOV	A,B		;COPY NUMBER OF ADDRESSES TO REG A
	ORA	A		;CHECK IF LIST IS ACTUALLY EMPTY
	RZ			;IF LIST LENGTH IS ZERO, QUIT
	LXI	H,GETMLISTINST2	;RUNNING, SEND EXIT INSTRUCTIONS TO USER
	CALL	SENDSTRING

MEMWRITERESET:			;NOW DO A READ/WRITE OF EACH ADDRESS IN LIST
	LXI	H,INPBUFF	;HL WILL BE POINTER TO CURRENT ENTRY IN ADDRESS LIST
	EI			;SEND INTE STROBE FOR LOGIC PROBE TRIGGER
	DI			;
	MOV	C,B		;RELOAD NUMBER OF ADDRESSES INTO C FOR COUNTER

MEMWRITE:	
	MOV	D,M		;GET ADDRESS FROM LIST AND PUT INTO DE PAIR, BIG ENDIAN
	INX	H
	MOV	E,M
	INX	H
	LDA	BUFFER1		;FILL BYTE INTO ACC
	STAX	D		;WRITE MEMORY LOCATION
	DCR	C		;ONE DONE
	JNZ	MEMWRITE	;MORE TO DO
	LDA	STOP_FLAG	;GET STOP FLAG WHICH WAS SET BY CI SUBROUTINE
	RLC			;COPY MSBIT INTO CARRY 
	RNC 			; IF LOW, USER ENTERED A CHARACTER
	JMP	MEMWRITERESET	;NO CHARACTER SO RESET LIST POINTER AND REDO


MEMWRTMSG1	DB	"WARNING: TAKE CARE WRITING TO STACK AREA",CR,LF
MEMWRTMSG2	DB	"STACK WILL BE RESET AFTER TEST",CR,LF,ETX
CMD_W_USE:	DB	"W -- (W)RITE PATTERN TO A LIST OF MEMORY LOCATIONS", CR, LF, ETX


;********************************************************************
;******************  ZERO JUMP BRANCH (RESTART) ********************
;  NAME: CMD_Z
;  FUNCTION: JUMPS TO 0000H (RESTART)
;  INPUTS: NONE
;  OUTPUTS: NONE
;  USER IO: NONE
;  DESTROYS: EVERYTHING
;  CALLS: NOTHING
;  DESCRIPTION:JUMP TO ADDRESS 0000H
;*********************************************************************

CMD_Z:
	LXI	H,MSG_Z		;POINT TO 'VERSION' MESSAGE
	CALL	SENDSTRING
	CALL	CI		;WAIT FOR USER KEYSTROKE
	JMP	0000H


MSG_Z	DB	"PRESS ANY KEY TO JUMP TO 0x0000 FOR RESTART", CR, LF, ETX
CMD_Z_USE:	DB	"Z -- (Z)ERO JUMP", CR, LF, ETX



;================================================================================
;================================================================================
;**************************               ***************************
;**************************  SUBROUTINES  ***************************
;**************************               ***************************
;================================================================================
;================================================================================



;================================================================================
;****************  BINARY OUTPUT BYTE SUBROUTINE  *******************
;  NAME: BOB
;  FUNCTION: SENDS PATTERN IN REGISTER A TO SERIAL PORT IN BINARY ASCII
;  INPUTS: BYTE PATTERN IN A
;  OUTPUTS: NONE
;  USER IO: SENDS ASCII 0 / 1 STRING TO TERMINAL REPRESENTING BYTE
;  DESTROYS: NOTHING
;  CALLS: BON
;  DESCRIPTION:DISPLAYS THE BYTE VALUE IN A AS BINARY
;================================================================================
BOB:	PUSH	PSW
	CALL	BON		;OUTPUT HIGH NIBBLE
	CALL	SENDSPACE
	RLC			;MOVE LOW NIBBLE TO TOP
	RLC
	RLC
	RLC
	CALL	BON		;OUTPUT LOW NIBBLE
	POP	PSW
	RET


;================================================================================
;*******************  BINARY OUTPUT NIBBLE SUBROUTINE  **********************
;  NAME: BON
;  FUNCTION: SENDS MOST SIGNIFICANT PATTERN IN REGISTER A TO SERIAL PORT IN BINARY ASCII
;  INPUTS: MOST SIGNIFICANT NIBBLE OF PATTERN IN A
;  OUTPUTS: NONE
;  USER IO: SENDS ASCII STRING OF 0s AND 1s TO TERMINAL REPRESENTING NIBBLE
;  DESTROYS: NOTHING
;  CALLS: CO
;  DESCRIPTION:DISPLAYS THE MOST SIGNIFICANT NIBBLE VALUE IN A AS BINARY
;================================================================================
BON:	PUSH	PSW
	PUSH	B		;SAVE BC PAIR, PUT COUNTER IN B, CHAR IN C
	MOV	C,A		;SAVE PATTERN IN C
	MVI	B,04H		;NUMBER OF BITS TO SEND OUT
BON1:
	MOV	A,C		;GET PATTERN
	RLC			;ROTATE MSBIT INTO CARRY
	MOV	C,A		;SAVE PATTERN 
	MVI	A,"1"		;PRELOAD 1
	JC	BON2		;SKIP NEXT IF GUESSED RIGHT
	MVI	A,"0"		;CHANGE IF GUESSED WRONG

BON2:
	CALL	CO		;OUTPUT		
	DCR	B
	JNZ	BON1		;LOOP UNTIL DONE
	POP	B	
	POP	PSW
	RET			;DONE WITH NIBBLE	






;================================================================================
;=======================  BREAKPOINT CLEAR SUBROUTINE  ============================
;  NAME: BP_CLEAR
;  FUNCTION: CLEARS USER SPECIFIED BREAKPOINT
;  INPUTS: NONE
;  OUTPUTS: 
;  USER IO: 
;  DESTROYS: A, F/F'S
;  CALLS: 
;  DESCRIPTION:ALLOWS USER TO CLEAR (RESET) BREAKPOINTS
;================================================================================
BP_CLEAR:
	CALL	BP_DISPLAY

;================================================================================
;=======================  BREAKPOINT DISPLAY SUBROUTINE  ============================
;  NAME: BP_DISPLAY
;  FUNCTION:DISPLAYS CURRENT BREAKPOINT TABLE
;  INPUTS: NONE
;  OUTPUTS: 
;  USER IO: 
;  DESTROYS: A, F/F'S
;  CALLS: 
;  DESCRIPTION:ALLOWS USER TO CLEAR (RESET) BREAKPOINTS
;================================================================================
BP_DISPLAY:

	LXI	H,BP_TBL_HEADING	;DISPLAY BREAKPOINT TABLE COLUMN HEADINGS
	CALL	SENDSTRING
	LXI	H,BP_TABLE		;BREAKPOINT TABLE ADDRESS
	MVI	B,0			;BREAKPOINT ID

BP_TBL_DISP:
	MOV	A,B			;BREAKPOINT ID INTO A FOR DISPLAY
	CALL	HO			;SEND
	MVI	A,HT
	CALL	CO			;TAB OVER
	MOV	D,M
	INX	H
	MOV	E,M
	CALL	SEND_DE			;DISPLAY BREAKPOINT ADDRESS
	MVI	A,HT
	CALL	CO			;TAB OVER
	INX	H
	MOV	A,M			;GET OPCODE
	INX	H
	CPI	08H			;IS IT DISABLED?
	JNZ	BP_TBL_OPCODE		; NO, CONTINUE
	MVI	A,"-"			; YES, REPLACE WITH DASH
	CALL	CO			; SEND TO CO
	JMP	BP_TBL_NOTOPCODE	; THEN CONTINUE
BP_TBL_OPCODE:
	CALL	HO			;SEND OPCODE
BP_TBL_NOTOPCODE
	CALL	NEWLINE			;
	INR	B			;NEXT BREAKPOINT ID
	MOV	A,B			;PUT BREAKPOINT ID INTO ACC FOR TEST
	CPI	BP_TABLE_LEN		;ARE WE DONE?
	JC	BP_TBL_DISP		; NO, DO ANOTHER ONE

	RET				; YES, RETURN
	
BP_TBL_HEADING:	DB	"ID",HT,"ADDRESS",HT,"OP CODE", CR,LF,LF, ETX



;================================================================================
;=======================  BREAKPOINT HIT SUBROUTINE  ============================
;  NAME: BP_HIT
;  FUNCTION: RESPONDS TO BREAKPOINT HIT
;  INPUTS: NONE
;  OUTPUTS: 
;  USER IO: 
;  DESTROYS: A, F/F'S
;  CALLS: 
;  DESCRIPTION:JUMPED TO WHEN BREAKPOINT HIT.  DISPLAY PROCESSOR STATUS
;================================================================================
;BP_HIT:


;================================================================================
;=======================  BREAKPOINT RESTORE SUBROUTINE  ============================
;  NAME: BP_RESTORE
;  FUNCTION: SETS USER SPECIFIED BREAKPOINT
;  INPUTS: NONE
;  OUTPUTS: 
;  USER IO: 
;  DESTROYS: A, F/F'S
;  CALLS: 
;  DESCRIPTION:ALLOWS USER TO SET BREAKPOINT ADDRESS
;================================================================================
BP_RESTORE:
	CALL	BP_DISPLAY

;================================================================================
;=======================  BREAKPOINT SET SUBROUTINE  ============================
;  NAME: BP_SET
;  FUNCTION: SETS USER SPECIFIED BREAKPOINT
;  INPUTS: NONE
;  OUTPUTS: 
;  USER IO: 
;  DESTROYS: A, F/F'S
;  CALLS: 
;  DESCRIPTION:ALLOWS USER TO SET BREAKPOINT ADDRESS
;================================================================================
BP_SET:
	CALL	BP_DISPLAY




;================================================================================
;************************  CI SUBROUTINE  ***************************
;  NAME: CI
;  FUNCTION: WAITS UNTIL A CHARACTER IS ENTERED AT THE SERIAL PORT
;  INPUTS: NONE
;  OUTPUTS: RECEIVED CHARACTER - REGISTER A
;  USER IO: WAITS FOR CHARACTER INPUT VIA SERIAL PORT SID
;  DESTROYS: A, F/F'S, DI
;  CALLS: DELAY, TOUPPER
;  DESCRIPTION:LOOPS UNTIL A CHARACTER IS RECEIVED AT THE SERIAL PORT
;          SHIFTS THE CHARACTER TO UPPER CASE IF NECESSARY
;================================================================================
CI:	DI   			;
	PUSH 	D		; SAVE DE
CI05:
  	RIM			; GET INPUT BIT
	RAL  			; INTO CARRY WITH IT
	JC   	CI05		; LOOP UNTIL START BIT
CI_START:			; CALL HERE IF USING CI CHECK VERSION
      LXI  	D,WAITD	; WAIT UNTIL MIDDLE OF BIT
	CALL 	DELAY		;
	PUSH 	B		; SAVE BC
	MVI	B,00H		;B<--0, 
	MVI  	C,SBITS    	;C<--# BITS TO RECEIVE
CI10:
  	LXI  	D,IBTIMD	; WAIT UNTIL MIDDLE OF NEXT BIT
	CALL 	DELAY		; 
	RIM			; GET THE BIT
	RAL  			; INTO CARRY
        MOV  	A,B		; GET PARTIAL RESULT
	RAR  			; SHIFT IN NEXT DATA BIT
	MOV  	B,A		; REPLACE RESULT
	DCR     C		; DECREMENT COUNT OF BITS TO GO
	JNZ  	CI10		; BRANCH IF MORE LEFT
	LXI  	D,IBTIMD	; ELSE, WANT TO WAIT OUT STOP BIT
	CALL 	DELAY		;
	MOV  	A,B		; GET RESULT
	POP  	B		;
	POP  	D		; RESTORE SAVED REGISTERS
	CALL	TOUPPER
	RET	     		; THAT'S IT, RETURN TO GETCH



;********************************************************************
;************************  CI CHECK SUBROUTINE  ***************************
;  NAME: CICHECK
;  FUNCTION: CHECKS IF A CHARACTER IS INPUT, TIMEOUTS IF NOTHING RECEIVED
;  INPUTS: NONE
;  OUTPUTS: RECEIVED CHARACTER - REGISTER A
;  USER IO: WAITS FOR CHARACTER INPUT VIA SERIAL PORT SID
;  DESTROYS: A, F/F'S, DI
;  CALLS: DELAY, TOUPPER
;  DESCRIPTION:REALLY ONLY USED TO TIMEOUT DOWNLOAD
;********************************************************************
CICHECK:
	DI
	PUSH	D
	LXI	D,02FFFH	;LOAD A TIMEOUT VALUE
CICHECK_WAIT:
	RIM
	RAL
	JNC	CI_START	;IF A START BIT, THEN GET CHARACTER
	DCX	D		;OTHERWISE DECREMENT TIMEOUT
	MOV	A,D		;D INTO ACCUMULATOR
	ORA	E		;SEE IF ANYTHING LEFT OF TIMEOUT COUTNER
	JNZ	CICHECK_WAIT	;YES, WAIT SOME MORE

	POP	D
	RET			;NO, RETURN WITH ACCUMULATOR EMPTY




;================================================================================
;************************  CO SUBROUTINE  ***************************
;  NAME: CO
;  FUNCTION: TRANSMITS A CHARACTER OUT THE SERIAL PORT
;  INPUTS: REGISTER A - CHARACTER TO BE SENT
;  OUTPUTS: IF SID GOES LOW AT ANY TIME, SET MSBIT OF CHARACTER BUFFER
;  USER IO: SENDS CHARACTER VIA SERIAL PORT
;  DESTROYS: NOTHING
;  CALLS: DELAY
;  DESCRIPTION:SENDS THE CHARACTER OUT THE SOD (INVERTED)
;       MEANWHILE, IT LOOKS AT SID IN EACH BIT AND CHECKS IF A CHARACTER
;       WAS INPUT FROM KEYBOARD. CHARACTER IS LOST BUT FLAG IS SET
;       SO CALLING ROUTINE KNOWS USER DID SOMETHING, E.G., STOP LOOP
;================================================================================
CO:     DI   			; DON'T ALLOW INTERRUPTS
	PUSH	PSW		;SAVE CHARACTER
	PUSH 	B		; SAVE BC
	PUSH 	D		; SAVE DE
	MOV	C,A		; MOVE CHARACTER TO OUTPUT INTO C
	MVI  	A,STRT		; START BIT MASK
	MVI  	B,SBITS 	; B WILL COUNT BITS TO SEND
CO05:
  	SIM			; SEND A BIT
	LXI  	D,OBTIMD	; WAIT FOR TTY TO HANDLE IT
        CALL 	DELAY		;
	MOV  	A,C		; PICK UP BITS LEFT TO SEND
	RAR  			; LOW ORDER BIT INTO CARRY
	MOV  	C,A		; PUT REST BACK
	MVI  	A,SSTRT		; SHIFTED ENABLE BIT
	RAR  			; SHIFT IN DATA BIT
	DCR  	B		; DECREMENT COUNT
	JP   	CO05		; SEND IF MORE BITS NEED TO BE SENT
	MVI  	A,STOPB		; ELSE, SEND STOP BITS
	SIM			; WAIT 4 BIT TIME (FAKE PARITY + 3 STOP BITS)
	LXI  	D,TIM4D		;
	CALL 	DELAY		;
	POP  	D		; RESTORE SAVED REGISTERS
	POP  	B		;
	POP	PSW		;RESTORE CHARACTER
	RET  			; ALL DONE



;================================================================================
;**********************  DELAY SUBROUTINE  **************************
;  NAME: DELAY
;  FUNCTION: COUNTER DELAY
;  INPUTS: DE - 16 BIT INTEGER DENOTING NUMBER OF TIMES TO LOOP
;  OUTPUTS: SETS STOP FLAG BUFFER IF USER INPUT CHARACTER DURING DELAY
;  USER IO: 
;  DESTROYS: A,D,E
;  CALLS: NOTHING
;  DESCRIPTION:DELAY DOES NOT RETURN TO CALLER UNTIL INPUT ARGUMENT
;              IS COUNTED DOWN TO 0
;================================================================================
DELAY:
	PUSH	H		;SAVE H
	LXI	H,STOP_FLAG	;STOP FLAG
DELAY05:
	RIM			;READ SID
	ANA	M		;CLEAR THE MSBIT IF SID IS LOW
	MOV	M,A		;AND PUT NEW VALUE INTO MEMORY LOCATION
	DCX  	D		; DECREMENT INPUT ARGUMENT
	MOV  	A,D		;
	ORA  	E		;
	JNZ  	DELAY05		; IF ARGUMENT NOT 0, KEEP GOING
	POP	H		;RESTORE H
	RET  


;================================================================================
;*************  GET HEX NIBBLE, HEX BYTE, OR HEX WORD SUBROUTINE  ***************
;  NAME: GETHEXNIBBLE, GETHEXBYTE, GETHEXWORD
;  FUNCTION: RECEIVES A 2 OR 4 DIGIT HEX VALUE FROM USER
;  INPUTS: NONE
;  OUTPUTS: 2 DIGIT VALUE IN L OR 4 DIGIT HEX VALUE IN HL, ZERO FLAG SET IF SHORT
;	CARRY IS SET IF ESCAPE IS ENTERED
;	L IS DUPLICATED IN A BEFORE RETURN FOR CONVENIENCE
;  USER IO: INPUT FROM USER UNTIL CARRIAGE RETURN
;  DESTROYS: A,F/F'S, HL
;  CALLS: CO, CI, TOHEX,
;  DESCRIPTION:GETS 1, 2, OR 4 DIGIT ADDRESS FROM USER DEPENDING ON ENTRY POINT,
;      LEAVE RESULT IN L (1/2 OR 1 BYTE) OR HL (2 BYTES).
;      ZERO FLAG IS CLEARED IF ENTERED COMPLETE, ZERO FLAG SET IF RETURNED
;      SHORT OF FULL ENTRY.  CARRY SET IF USER ENTERS ESCAPE
;================================================================================
GETHEXWORD:			;GET 4 DIGIT ADDRESS FROM USER, LEAVE IN HL
	CALL	CI
	CPI	CR		;IS IT A CARRIAGE RETURN
	RZ			;IF SO, RETURN EARLY WITH FLAG ZERO
	CPI	ESC		;IS IT AN ESCAPE?
	JZ	GHW_ESC		; YES, SET CARRY AND ABORT
	CALL	CO		; NO, CONTINUE BY ECHOING CHARACTER
	CALL	TOHEX		;CONVERT FROM ASCII TO HEX
	JNC	GHW05		;IF INPUT WAS OK, CONTINUE
	CALL	BADHEX		;OTHERWISE, TRY AGAIN
	JMP	GETHEXWORD
GHW05:	RLC			;SHIFT UP TO HIGH NIBBLE
	RLC
	RLC
	RLC
	MOV	H,A		;MSB, PUT INTO H
GHW10:	CALL	CI
	CPI	CR		;IS IT A CARRIAGE RETURN
	RZ			;IF SO, RETURN EARLY WITH FLAG ZERO
	CPI	ESC		;IS IT AN ESCAPE?
	JZ	GHW_ESC		; YES, SET CARRY AND ABORT
	CALL	CO		; NO, CONTINUE BY ECHOING CHARACTER
	CALL	TOHEX		;CONVERT FROM ASCII TO HEX
	JNC	GHW15		;IF INPUT WAS OK, CONTINUE
	CALL	BADHEX		;OTHERWISE, TRY AGAIN
	JMP	GHW10
GHW15:	ORA	H		;COMBINE WITH HIGH NIBBLE
	MOV	H,A		;HIGH BYTE IS DONE

GETHEXBYTE:			;ENTER HERE TO JUST GET 2 DIGIT HEX
GHW20:	CALL	CI
	CPI	CR		;IS IT A CARRIAGE RETURN
	RZ			;IF SO, RETURN EARLY WITH FLAG ZERO
	CPI	ESC		;IS IT AN ESCAPE?
	JZ	GHW_ESC		; YES, SET CARRY AND ABORT
GHB_CO:	CALL	CO		; NO, ECHO CHARACTER TO TERMINAL (ENTER HERE IF 1ST CHARACTER ALREADY RECEIVED)
	CALL	TOHEX		;CONVERT FROM ASCII TO HEX
	JNC	GHW25		;IF INPUT WAS OK, CONTINUE
	CALL	BADHEX		;OTHERWISE, TRY AGAIN
	JMP	GETHEXBYTE
GHW25:	RLC			;SHIFT UP TO HIGH NIBBLE
	RLC
	RLC
	RLC
	MOV	L,A		;PUT INTO L
GETHEXNIBBLE:
GHW30:	CALL	CI
GHNCPI:	CPI	CR		;IS IT A CARRIAGE RETURN (ENTER HERE IF CHARACTER RECEIVED (DO CR TEST)
	RZ			;IF SO, RETURN EARLY WITH FLAG ZERO
	CPI	ESC		;IS IT AN ESCAPE?
	JZ	GHW_ESC		; YES, SET CARRY AND ABORT
GHN_CO:	CALL	CO		; NO, ECHO CHARACTER TO USER (ENTER HERE IF CHARACTER RECEIVED (SKIP CR TEST)
	CALL	TOHEX		;CONVERT FROM ASCII TO HEX
	JNC	GHW35		;IF INPUT WAS OK, CONTINUE
	CALL	BADHEX		;OTHERWISE, TRY AGAIN
	JMP	GHW30
GHW35:	ORA	L		;COMBINE WITH HIGH NIBBLE
	MOV	L,A		;LOW BYTE IS DONE
	ORI	01H		;CLEAR THE ZERO FLAG, MEANS VALID VALUE
	MOV	A,L		;RETURNED VALUE IN L, DUPLICATE IN ACC.
	RET

GHW_ESC:
	STC			;SET CARRY
	RET			;RETURN

BADHEX:
	MVI	A,BELL		;SEND BELL
	CALL	CO
	MVI	A,BS		;SEND BACKSPACE
	CALL	CO
	RET


;================================================================================
;*************  GET MEMORY R/W LIST SUBROUTINE  ***************
;  NAME: GET_MLIST
;  FUNCTION: SEQUENCES THROUGH LIST OF MEMORY LOCATIONS TO READ OR WRITE
;  INPUTS: NONE
;  OUTPUTS: 
;	B: NUMBER OF ADDRESSES IN LIST
;	INPUTBUFF:COMPLETED ADDRESS LIST	
;  USER IO: REQUESTS LIST OF ADDRESSES, END LIST INPUT WITH A CARRIAGE RETURN
;  DESTROYS: PSW,BC,DE,HL
;  CALLS: SENDSTRING, GETUIADDRESS, NEWLINE
;  DESCRIPTION:SENDS INSTRUCTIONS TO USER, GETS LIST OF MEMORY LOCATIONS FOR TESTING
;      
;================================================================================
GET_MLIST:
	LXI	H,GETMLISTINST	
	CALL	SENDSTRING	;INSTRUCTIONS TO USER
	LXI	D,INPBUFF	;PUT ADDRESS LIST STARTING POINTER IN DE
	MVI	B,00H		;NUMBER OF ADDRESS LOCATIONS IN B

GETMLISTADD:
	CALL	GETHEXWORD	;GET ADDRESS FROM USER, RETURNS WITH ADDRESS INTO HL
	RZ			;IF ZERO FLAG WAS SET, USER ENTERED BLANK LINE. INPUT IS COMPLETE
	CALL	NEWLINE		;OTHERWISE PUT OUT NEW LINE
	XCHG			;THEN PUT ADDRESS LIST POINTER IN HL, ADDRESS VALUE IN DE
	MOV	M,D		;PUT MSB IN FIRST MEMORY LOCATION - BIG ENDIAN STYLE
	INX	H		;POINT TO NEXT MEMORY
	MOV	M,E		;LSB
	INX	H		;POINT TO NEXT ADDRESS
	XCHG			;ADDRESS LIST BACK IN DE PAIR
	INR	B		;ONE MORE ADDRESS ON LIST
	JMP	GETMLISTADD	;CONTINUE UNTIL USER ENTERS CR TO TERMINATE INPUT

GETMLISTINST	DB	"ENTER MEMORY ADDRESS(ES) IN HEX (XXXX). CR TO TERMINATE ENTRY & START",CR,LF,ETX
GETMLISTINST2	DB	"RUNNING, INTE PIN IS STROBED AT THE BEGINNING OF EACH CYCLE.",CR,LF
GETMLISTINST3	DB	"  PRESS ANY KEY TO QUIT........",CR,LF,ETX

;================================================================================
;****************  HEXADECIMAL OUTPUT SUBROUTINE  *******************
;  NAME: HO
;  FUNCTION: SENDS BYTE VALUE IN REGISTER A TO TERMINAL IN HEXADECIMAL
;  INPUTS: PATTERN IN A
;  OUTPUTS: NONE
;  USER IO: SENDS ONE OR TWO ASCII CHARACTERS TO TERMINAL
;  DESTROYS: NOTHING
;  CALLS: CO
;  DESCRIPTION:ENTER AT HO TO SEND VALUE IN REGISTER TO AS TWO DIGIT HEX
;    REPRESENTATION OF VALUE.  ENTER AT HOL FOR OUTPUT OF ONLY
;    THE LOWER NIBBLE
;================================================================================
HO:	PUSH	PSW		;SAVE CHARACTER FOR LOW NIBBLE
	CALL	TOASCIIH	;CONVERT HIGH NIBBLE TO ASCII
	CALL	CO		;OUTPUT
	POP	PSW		;POP CHARACTER
HOL:	PUSH	PSW		;ENTER HERE FOR ONLY LOW NIBBLE
	CALL	TOASCIIL	;CONVERT LOW NIBBLE TO ASCII
	CALL	CO		;OUTPUT TO CONSOLE
	POP	PSW		;RESTORE PSW
	RET





;================================================================================
;**********************  NEWLINE SUBROUTINE  ************************
;  NAME: NEWLINE
;  FUNCTION: SENDS A NEWLINE (CR, LF) TO THE DISPLAY VIA SERIAL PORT
;  INPUTS: NONE
;  OUTPUTS: NONE
;  USER IO: SENDS NEWLINE TO TERMINAL VIA SERIAL PORT
;  DESTROYS: NOTHING
;  CALLS: CO
;  DESCRIPTION:SENDS A NEWLINE TO DISPLAY VIA SERIAL PORT
;================================================================================
NEWLINE:
	PUSH	PSW
	MVI	A,0DH
	CALL	CO
	MVI	A,0AH
	CALL	CO
	POP	PSW
	RET


;================================================================================
;******************  PROMPT SUBROUTINE  *********************
;  NAME: PROMPT
;  FUNCTION: SENDS A NEWLINE AND THEN A PROMPT TO THE SERIAL PORT
;  INPUTS: NONE
;  OUTPUTS: NONE
;  USER IO: SENDS NEWLINE AND COMMAND PROMPT VIA SERIAL PORT
;  DESTROYS: A, HL
;  CALLS: NEWLINE, SENDSTRING
;  DESCRIPTION:SENDS A NEWLINE AND THEN DISPLAYS THE COMMAND PROMPT
;    VIA SERIAL PORT. THEN LEAVES CURSER TO THE RIGHT OF THE PROMPT
;================================================================================
PROMPT:
	CALL	NEWLINE
	MVI	A,">"
	CALL	CO
	RET

;================================================================================
;***************  SEND CARRIAGE RETURN SUBROUTINE  ******************
;  NAME: SENDCR
;  FUNCTION: SENDS A CARRIAGE RETURN OUT THE SERIAL PORT
;  INPUTS: NONE
;  OUTPUTS: NONE
;  USER IO: SENDS A CR CHARACTER TO THE SERIAL PORT
;  DESTROYS: NOTHING
;  CALLS: CO
;  DESCRIPTION:SENDS A CR TO THE SERIAL PORT
;
;================================================================================
SENDCR:
	PUSH	PSW
	MVI	A,CR
	CALL	CO		;OUTPUT CHARACTER
	POP	PSW
	RET

;================================================================================
;**********************  SEND_BC SUBROUTINE  *************************
;  NAME: SEND_BC
;  FUNCTION: SENDS THE BC PAIR TO THE DISPLAY AS FOUR HEX ASCII CHARACTERS
;  INPUTS: NOTHING
;  OUTPUTS: NONE
;  USER IO: DISPLAYS VALUES TO USER VIA SERIAL PORT
;  DESTROYS: A, PSW
;  CALLS: TOASCII, CO
;  DESCRIPTION:CONVERTS THE VALUE IN THE BC REGISTER PAIR AND OUTPUTS
;    TO THE USER VIA THE SERIAL PORT AS FOUR HEXADECIMAL ASCII CHARACTERS
;    IT DOES NOT TERMINATE WITH A NEWLINE
;================================================================================
SEND_BC:
	MOV	A,B		;FIRST B
	CALL	HO		;HEX OUTPUT
	MOV	A,C		;NOW DO C
	CALL	HO
	RET

;================================================================================
;**********************  SEND_DE SUBROUTINE  *************************
;  NAME: SEND_DE
;  FUNCTION: SENDS THE DE PAIR TO THE DISPLAY AS FOUR HEX ASCII CHARACTERS
;  INPUTS: NOTHING
;  OUTPUTS: NONE
;  USER IO: DISPLAYS VALUES TO USER VIA SERIAL PORT
;  DESTROYS: A, PSW
;  CALLS: TOASCII, CO
;  DESCRIPTION:CONVERTS THE VALUE IN THE DE REGISTER PAIR AND OUTPUTS
;    TO THE USER VIA THE SERIAL PORT AS FOUR HEXADECIMAL ASCII CHARACTERS
;    IT DOES NOT TERMINATE WITH A NEWLINE
;================================================================================
SEND_DE:
	MOV	A,D
	CALL	HO		;HEX OUTPUT
	MOV	A,E		;NOW DO E
	CALL	HO
	RET


;================================================================================
;**********************  SEND_HL SUBROUTINE  *************************
;  NAME: SEND_HL
;  FUNCTION: SENDS THE HL PAIR TO THE DISPLAY AS FOUR HEX ASCII CHARACTERS
;  INPUTS: NOTHING
;  OUTPUTS: NONE
;  USER IO: DISPLAYS VALUES TO USER VIA SERIAL PORT
;  DESTROYS: A, PSW
;  CALLS: TOASCII, CO
;  DESCRIPTION:CONVERTS THE VALUE IN THE HL REGISTER PAIR AND OUTPUTS
;    TO THE USER VIA THE SERIAL PORT AS FOUR HEXADECIMAL ASCII CHARACTERS
;    IT DOES NOT TERMINATE WITH A NEWLINE
;================================================================================
SEND_HL:
	MOV	A,H
	CALL	HO
	MOV	A,L		;NOW DO L
	CALL	HO
	RET



;================================================================================
;********************  SEND SPACE SUBROUTINE  ***********************
;  NAME: SENDSPACE
;  FUNCTION: SENDS A SPACE OUT THE SERIAL PORT
;  INPUTS: NONE
;  OUTPUTS: NONE
;  USER IO: SENDS A SPACE CHARACTER TO THE SERIAL PORT
;  DESTROYS: NOTHING
;  CALLS: CO
;  DESCRIPTION:SENDS A SPACE TO THE SERIAL PORT
;
;================================================================================
SENDSPACE:
	PUSH	PSW
	MVI	A,SPACE
	CALL	CO		;OUTPUT CHARACTER
	POP	PSW
	RET

;================================================================================
;********************  SEND STRING SUBROUTINE  ***********************
;  NAME: SENDSTRING
;  FUNCTION: SENDS A TERMINATED STRING TO THE DISPLAY
;  INPUTS: POINTER TO STRING IN HL
;  OUTPUTS: NONE
;  USER IO: SENDS STRING TO USER VIA SERIAL PORT
;  DESTROYS: HL
;  CALLS: CO
;  DESCRIPTION:DISPLAYS EACH CHARACTER IN THE PROVIDED STRING TO THE USER
;    VIA THE SERIAL PORT.  A HANDLE TO THE STRING IS PROVIDED IN THE HL PAIR
;    AND THE OUTPUT CONTINUES UNTIL AN END OF TEXT (ETX) CONTROL CHARACTER IS
;    FOUND
;    #### WARNING ####
;    ALL STRINGS MUST END WITH A ETX 
;================================================================================
SENDSTRING:
	PUSH	PSW		;SAVE A, F/FS
SENDSTRING01:
	MOV	A,M		;GET CHARACTER
	CPI	ETX		;END OF TEXT?
	JZ	SENDSTRING05	;YES, RETURN
	CALL	CO		;NO, OUTPUT CHARACTER
	INX	H		;NEXT CHARACTER
	JMP	SENDSTRING01	;OUTPUT UNTIL DONE
SENDSTRING05:
	POP	PSW		;RESTORE A, F/FS
	RET
;================================================================================
;***************  SEND HORIZONTAL TAB SUBROUTINE  ******************
;  NAME: SENDTAB
;  FUNCTION: SENDS A TAB CHARACTER OUT THE SERIAL PORT
;  INPUTS: NONE
;  OUTPUTS: NONE
;  USER IO: SENDS A CR CHARACTER TO THE SERIAL PORT
;  DESTROYS: NOTHING
;  CALLS: CO
;  DESCRIPTION:SENDS A TAB TO THE SERIAL PORT
;
;================================================================================
SENDTAB:
	PUSH	PSW
	MVI	A,HT
	CALL	CO		;OUTPUT CHARACTER
	POP	PSW
	RET


;================================================================================
;*********************  TOASCII SUBROUTINE  *************************
;  NAME: TOASCII, TOASCIIH, TOASCIIL
;  FUNCTION: CONVERTS THE NIBBLE OF RECEIVED HEXADECIMAL CHARACTER TO ASCII
;  INPUTS: HEXADECIMAL CHARACTER IN REGISTER A
;  OUTPUTS: RETURNS ASCII CHARACTER IN REGISTER A
;  USER IO: NONE
;  DESTROYS: A, PSW
;  CALLS: NOTHING
;  DESCRIPTION: CONVERTS EITHER THE HIGH OR LOW NIBBLE OF THE HEXADECIMAL
;   0-F STORED IN REGISTER A TO THE ASCII ALPHANUMERIC
;    
;================================================================================
TOASCIIH:
	ANI	11110000B	;CLEAR BOTTOM
	RRC			;ROTATE TO BOTTOM
	RRC
	RRC
	RRC
	JMP	TOASCII
TOASCIIL:
	ANI	00001111B	;CLEAR TOP

TOASCII:
	ADI	"0"		;MOVE VALUE UP TO ASCII ZERO
	CPI	"9"+1		;JUMP IF NOT NUMERIC
	RC			;DONE IF NUMERIC SO RETURN
	ADI	07H		;OTHERWISE, BUMP UP TO "A"
	CPI	SPACE		;IS CHARACTER LESS THAN A SPACE
	JC	ASCIIDOT	;YES, NON PRINTABLE CONVERT TO DOT
	CPI	"~"
	RC			;~ OR SMALLER, SO OK TO DISPLAY

ASCIIDOT:
	MVI	A,"."
	RET			;THEN RETURN



;================================================================================
;*********************  TOHEX SUBROUTINE  *************************
;  NAME: TOHEX
;  FUNCTION: CONVERTS THE ASCII CHARACTER IN REGISTER A INTO HEX
;  INPUTS: ASCII CHARACTER IN REGISTER A
;  OUTPUTS: RETURNS HEX VALUE IN LOW NIBBLE OF REGISTER A
;  USER IO: NONE
;  DESTROYS: A, F/F'S
;  CALLS: NOTHING
;  DESCRIPTION: TAKES THE ASCII 0-9, A-F AND CONVERTS TO HEX NIBBLE
;    E.G., ASCII 2 IS RETURNED AS 02H, F IS RETURNED AS 0FH, INPUT
;    IS TESTED AND IF NOT FROM 0 TO F THE CARRY IS SET UPON RETURN  
;================================================================================
TOHEX:
	CPI	":"		
	JC	TOHEX05		;JUMP IF INPUT IS ABOVE NUMBERS
	SUI	07H		;THEN REMOVE 9-A GAP
TOHEX05:
	SUI	"0"		;SUBTRACT OFF ASCII "0"
	RC			; IF NEGATIVE, THEN RETURN IN ERROR
	CPI	00FH+1		;IS THE INPUT GREATER THAN 0X0F?
	JNC	TOHEXERR	; NO CARRY, INPUT IS TOO BIG
	CMC			; YES, INPUT IS OK SO CLEAR CARRY
	RET			;  AND RETURN
TOHEXERR:
	STC			;INPUT TOO LARGE SO SET CARRY
	RET			;  AND RETURN


;================================================================================
;*********************  TOUPPER SUBROUTINE  *************************
;  NAME: TOUPPER
;  FUNCTION: CONVERTS THE ASCII CHARACTER IN REGISTER A INTO UPPER CASE
;  INPUTS: ASCII CHARACTER IN REGISTER A
;  OUTPUTS: RETURNS UPPER CASE VALUE FOR INPUT
;  USER IO: NONE
;  DESTROYS: A, F/F'S
;  CALLS: NOTHING
;  DESCRIPTION: TAKES ASCII CHARACTER AND IF LOWER CASE SHIFTS TO UPPER  
;================================================================================
TOUPPER:
	CPI	"a"		;COMPARE TO LOWER CASE
	RC			;RETURN IF CHARACTER IS ALREADY LESS THAN 'a'
	SUI	"a"-"A"		;DOWN SHIFT
	RET



;********************************************************************
;********************** ADDITIONAL INCLUDES **************************
;********************************************************************
	INCL	"PL7303.a85"
	INCL	"banner.txt"


	END
